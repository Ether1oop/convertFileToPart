@@ -321,7 +321,7 @@ contract DOSProxy is Ownable {
         uint idx = dispatchJobCore(TrafficType.SystemRandom, uint(blockhash(block.number - 1)));
         // TODO: keep id receipt and handle later in v2.0.
         if (idx == UINTMAX) {
-            emit LogMessage("No live working group, trigger bootstrap");
+            emit LogMessage("no-live-wgrp,try-bootstrap");
             return;
         }
 
@@ -456,7 +456,7 @@ contract DOSProxy is Ownable {
                 uint idx = dispatchJob(TrafficType.UserQuery, queryId);
                 // TODO: keep id receipt and handle later in v2.0.
                 if (idx == UINTMAX) {
-                    emit LogMessage("No live working group, skipped query");
+                    emit LogMessage("skipped-user-query-no-live-wgrp");
                     return 0;
                 }
                 Group storage grp = workingGroups[workingGroupIds[idx]];
@@ -492,7 +492,7 @@ contract DOSProxy is Ownable {
         uint idx = dispatchJob(TrafficType.UserRandom, requestId);
         // TODO: keep id receipt and handle later in v2.0.
         if (idx == UINTMAX) {
-            emit LogMessage("No live working group, skipped random request");
+            emit LogMessage("skipped-user-rnd-no-live-wgrp");
             return 0;
         }
         Group storage grp = workingGroups[workingGroupIds[idx]];
@@ -644,7 +641,7 @@ contract DOSProxy is Ownable {
     ///  Anyone including but not limited to DOS client node can be a guardian and claim rewards.
     function signalRandom() public {
         if (lastUpdatedBlock + refreshSystemRandomHardLimit > block.number) {
-            emit LogMessage("SystemRandom not expired yet");
+            emit LogMessage("sys-random-not-expired");
             return;
         }
 
@@ -662,7 +659,7 @@ contract DOSProxy is Ownable {
             emit GuardianReward(block.number, msg.sender);
             DOSPaymentInterface(addressBridge.getPaymentAddress()).claimGuardianReward(msg.sender);
         } else {
-            emit LogMessage("No expired pending group to clean up");
+            emit LogMessage("no-expired-pgrp-to-clean");
         }
     }
     /// @dev Guardian signals to trigger group formation when there're enough pending nodes.
@@ -672,26 +669,26 @@ contract DOSProxy is Ownable {
             emit GuardianReward(block.number, msg.sender);
             DOSPaymentInterface(addressBridge.getPaymentAddress()).claimGuardianReward(msg.sender);
         } else {
-            emit LogMessage("No group formation");
+            emit LogMessage("no-grp-formation");
         }
     }
     function signalBootstrap(uint _cid) public {
-        require(bootstrapRound == _cid, "Not in bootstrap phase");
+        require(bootstrapRound == _cid, "not-in-bootstrap");
 
         if (block.number <= bootstrapEndBlk) {
-            emit LogMessage("Waiting to collect more entropy");
+            emit LogMessage("wait-to-collect-more-entropy");
             return;
         }
         if (numPendingNodes < bootstrapStartThreshold) {
-            emit LogMessage("Not enough nodes to bootstrap");
+            emit LogMessage("not-enough-p-node-to-bootstrap");
             return;
         }
         // Reset.
         bootstrapRound = 0;
         bootstrapEndBlk = 0;
         uint rndSeed = CommitRevealInterface(addressBridge.getCommitRevealAddress()).getRandom(_cid);
         if (rndSeed == 0) {
-            emit LogMessage("CommitReveal failure, bootstrapRound reset");
+            emit LogMessage("bootstrap-commit-reveal-failure");
             return;
         }
         lastRandomness = uint(keccak256(abi.encodePacked(lastRandomness, rndSeed)));
@@ -713,7 +710,7 @@ contract DOSProxy is Ownable {
             emit GuardianReward(block.number, msg.sender);
             DOSPaymentInterface(addressBridge.getPaymentAddress()).claimGuardianReward(msg.sender);
         } else {
-            emit LogMessage("Nothing to unregister");
+            emit LogMessage("nothing-to-unregister");
         }
     }
     /// End of Guardian functions
@@ -838,7 +835,7 @@ contract DOSProxy is Ownable {
                 return true;
             } else {
                 // TODO: Do small bootstrap in this condition?
-                emit LogMessage("Skipped group formation, not enough expired working group.");
+                emit LogMessage("skipped-formation-not-enough-expired-wgrp");
             }
         } else if (numPendingNodes >= bootstrapStartThreshold) { // No working group alive and satisfies system re-bootstrap condition.
             if (bootstrapRound == 0) {
@@ -851,17 +848,17 @@ contract DOSProxy is Ownable {
                 bootstrapEndBlk = block.number + bootstrapCommitDuration + bootstrapRevealDuration;
                 return true;
             } else {
-                emit LogMessage("Already in bootstrap phase");
+                emit LogMessage("already-in-bootstrap");
             }
         }
         return false;
     }
 
     // callback to handle re-grouping using generated random number as random seed.
     function __callback__(uint requestId, uint rndSeed) external {
-        require(msg.sender == address(this), "Unauthenticated response");
-        require(expiredWorkingGroupIds.length >= groupToPick, "No enough expired working group");
-        require(numPendingNodes >= groupSize, "Not enough newly registered nodes");
+        require(msg.sender == address(this), "unauthenticated-resp");
+        require(expiredWorkingGroupIds.length >= groupToPick, "regroup-not-enough-expired-wgrp");
+        require(numPendingNodes >= groupSize, "regroup-not-enough-p-node");
 
         uint arrSize = groupSize * (groupToPick + 1);
         address[] memory candidates = new address[](arrSize);

