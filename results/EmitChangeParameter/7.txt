@@ -3,7 +3,7 @@ pragma solidity >=0.6.0;
 import "../deployment/Deployer.sol";
 import "../deployment/ManagedContract.sol";
 import "../governance/ProtocolSettings.sol";
-import "../utils/ERC20.sol";
+import "../interfaces/IERC20.sol";
 import "../interfaces/TimeProvider.sol";
 import "../utils/MoreMath.sol";
 import "../utils/SafeMath.sol";
@@ -25,7 +25,6 @@ contract CreditProvider is ManagedContract {
     mapping(address => uint) private callers;
 
     address private ctAddr;
-    uint private _totalAccruedFees;
 
     event DepositTokens(address indexed to, address indexed token, uint value);
 
@@ -37,6 +36,8 @@ contract CreditProvider is ManagedContract {
 
     event BurnDebt(address indexed from, uint value);
 
+    event AccrueFees(address indexed from, uint value);
+
     function initialize(Deployer deployer) override internal {
 
         time = TimeProvider(deployer.getContractAddress("TimeProvider"));
@@ -46,6 +47,7 @@ contract CreditProvider is ManagedContract {
         callers[address(settings)] = 1;
         callers[address(creditToken)] = 1;
         callers[deployer.getContractAddress("OptionsExchange")] = 1;
+        callers[deployer.getContractAddress("UnderlyingVault")] = 1;
         callers[deployer.getContractAddress("LinearLiquidityPool")] = 1;
 
         ctAddr = address(creditToken);
@@ -56,16 +58,11 @@ contract CreditProvider is ManagedContract {
         address[] memory tokens = settings.getAllowedTokens();
         for (uint i = 0; i < tokens.length; i++) {
             (uint r, uint b) = settings.getTokenRate(tokens[i]);
-            uint value = ERC20(tokens[i]).balanceOf(address(this));
+            uint value = IERC20(tokens[i]).balanceOf(address(this));
             v = v.add(value.mul(b).div(r));
         }
     }
 
-    function totalAccruedFees() external view returns (uint) {
-
-        return _totalAccruedFees;
-    }
-
     function ensureCaller(address addr) public view {
         
         require(callers[addr] == 1, "unauthorized caller");
@@ -99,7 +96,7 @@ contract CreditProvider is ManagedContract {
     
     function depositTokens(address to, address token, uint value) external {
 
-        ERC20(token).transferFrom(msg.sender, address(this), value);
+        IERC20(token).transferFrom(msg.sender, address(this), value);
         addBalance(to, token, value, true);
         emit DepositTokens(to, token, value);
     }
@@ -137,7 +134,7 @@ contract CreditProvider is ManagedContract {
             if (v > 0) {
                 uint fee = MoreMath.min(value.mul(v).div(b), balanceOf(from));
                 value = value.sub(fee);
-                _totalAccruedFees = _totalAccruedFees.add(fee);
+                emit AccrueFees(from, value);
             }
 
             uint credit;
@@ -152,7 +149,7 @@ contract CreditProvider is ManagedContract {
                 applyDebtInterestRate(from);
                 setDebt(from, debts[from].add(credit));
                 addBalance(to, credit);
-                emit AccumulateDebt(to, value);
+                emit AccumulateDebt(to, credit);
             }
         }
     }
@@ -234,7 +231,7 @@ contract CreditProvider is ManagedContract {
 
         address[] memory tokens = settings.getAllowedTokens();
         for (uint i = 0; i < tokens.length && value > 0; i++) {
-            ERC20 t = ERC20(tokens[i]);
+            IERC20 t = IERC20(tokens[i]);
             (uint r, uint b) = settings.getTokenRate(tokens[i]);
             if (b != 0) {
                 uint v = MoreMath.min(value, t.balanceOf(address(this)).mul(b).div(r));