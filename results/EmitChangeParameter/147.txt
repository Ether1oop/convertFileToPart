@@ -1,29 +1,44 @@
 pragma solidity 0.5.17;
 
-import "./oz/SafeMath.sol";
-import "./oz/IERC20.sol";
-import "./oz/ReentrancyGuard.sol";
+// ["0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa","0x295CA5bC5153698162dDbcE5dF50E436a58BA21e"] kDAI, kIdleDAI
+// ["0xDE2C7c260C851c0AF3db31409D0585bbE9D20a78","0x7136fbDdD4DFfa2369A9283B6E90A040318011Ca","0x3792acDf2A8658FBaDe0ea70C47b89cB7777A5a5"] test members
+// 1000000000000000000
+// 0x5465737450617274790a00000000000000000000000000000000000000000000
+
+import "./SafeMath.sol";
+import "./IERC20.sol";
+import "./NewReentrancy.sol";
+
+    /*=====================
+    WELCOME TO THE POOL Party v1
+    
+    **USE AT YOUR OWN RISK**
+    Forked from an early version of the permissioned Mystic v2x by LexDAO 
+    Special thanks to LexDAO for pushing the boundaries of Moloch mysticism 
+    
+    Developed by Peeps Democracy
+    MIT License - But please use for good (ie. don't be a dick). 
+    =======================*/
 
 interface IIdleToken {
   function token() external returns (address underlying);
+  function govTokens(uint256) external returns (address govToken);
   function userAvgPrices(address) external returns (uint256 avgPrice);
-  function mintIdleToken(uint256 _amount, bool _skipWholeRebalance) external returns (uint256 mintedTokens);
-  function redeemIdleToken(uint256 _amount, bool _skipRebalance, uint256[] calldata _clientProtocolAmounts) external returns (uint256 redeemedTokens);
+  function mintIdleToken(uint256 _amount, bool _skipWholeRebalance, address _referral) external returns (uint256 mintedTokens);
+  function redeemIdleToken(uint256 _amount) external returns (uint256 redeemedTokens);
   function redeemInterestBearingTokens(uint256 _amount) external;
   function rebalance() external returns (bool);
   function rebalanceWithGST() external returns (bool);
-  function openRebalance(uint256[] calldata _newAllocations) external returns (bool, uint256 avgApr);
   function tokenPrice() external view returns (uint256 price);
   function getAPRs() external view returns (address[] memory addresses, uint256[] memory aprs);
   function getAvgAPR() external view returns (uint256 avgApr);
-  function getCurrentAllocations() external view returns (address[] memory tokenAddresses, uint256[] memory amounts, uint256 total);
+  function getGovTokensAmounts(address _usr) external view returns (uint256[] memory _amounts);
 }
 
 
 contract Party is ReentrancyGuard {
     using SafeMath for uint256;
-    
-    IIdleToken public idleToken;
+
     
     /****************
     GOVERNANCE PARAMS
@@ -38,45 +53,49 @@ contract Party is ReentrancyGuard {
 
     address public daoFee; // address where fees are sent
     address public depositToken; // deposit token contract reference; default = periodDuration
-    address public minion; // contract that allows execution of arbitrary calls voted on by members // gov. param adjustments
-    bytes32 public name; 
-    bytes32 public desc;
+    address public idleToken; 
+    bool private initialized;
+
+    //address public constant idleToken = 0xB517bB2c2A5D690de2A866534714eaaB13832389;
 
 
     // HARD-CODED LIMITS
     // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations
     // with periods or shares, yet big enough to not limit reasonable use cases.
-    uint256 constant dilutionBound = 3; // default = 3 
+    uint256 constant dilutionBound = 5; // default = 5
     uint256 constant MAX_INPUT = 10**36; // maximum bound for reasonable limits
     uint256 constant MAX_TOKEN_WHITELIST_COUNT = 100; // maximum number of whitelisted tokens
 
     // ***************
     // EVENTS
     // ***************
     event SummonComplete(address[] indexed summoners, address[] tokens, uint256 summoningTime, uint256 periodDuration, uint256 votingPeriodLength, uint256 gracePeriodLength, uint256 proposalDepositReward, uint256 partyGoal, uint256 depositRate);
-    event MakeDeposit(address indexed memberAddress, uint256 indexed tribute, uint256 indexed shares);
-    event MakePayment(address indexed sender, address indexed paymentToken, uint256 indexed payment);
-    event AmendGovernance(address indexed newToken, address indexed minion, uint256 depositRate);
-    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details, bool[7] flags, uint256 proposalId, address indexed memberAddress);
-    event SponsorProposal(address sponsor, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);
+    event MakeDeposit(address indexed memberAddress, uint256 tribute, uint256 mintedTokens, uint256 indexed shares, uint256 idleAvgCost, uint8 goalHit);
+    event ProcessAmendGovernance(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass, address newToken, address newIdle, uint256 newPartyGoal, uint256 newDepositRate);    
+    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details, bool[8] flags, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);
+    event SponsorProposal(address indexed sponsor, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);
     event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);
-    event ProcessProposal(uint256 indexed proposalIndex, bool didPass);
+    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);
+    event ProcessIdleProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, uint256 idleRedemptionAmt, uint256 depositTokenAmt);
     event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);
     event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);
     event TokensCollected(address indexed token, uint256 amountToCollect);
     event CancelProposal(uint256 indexed proposalId, address applicantAddress);
+    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);
+    event WithdrawEarnings(address indexed memberAddress, uint256 earningsToUser, uint256 redeemedTokens);
     event Withdraw(address indexed memberAddress, address token, uint256 amount);
 
     // *******************
     // INTERNAL ACCOUNTING
     // *******************
-    uint8 private status;
-    uint8 private NOT_SET;
-    uint8 private constant SET = 1; // tracks contract summoning set
+
+    uint8 public goalHit; // tracks whether goal has been hit
     uint256 public proposalCount; // total proposals submitted
     uint256 public totalShares; // total shares across all members
     uint256 public totalLoot; // total loot across all members
-    uint256 public totalGuildBankTokens; // total tokens with non-zero balance in guild bank
+    uint256 public totalDeposits; //track deposits made for goal
+    uint256 public idleAvgCost; // track avg cost to be efficient with gas
+
 
     address public constant GUILD = address(0xdead);
     address public constant ESCROW = address(0xbeef);
@@ -90,7 +109,6 @@ contract Party is ReentrancyGuard {
     }
 
     struct Member {
-        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated
         uint256 shares; // the # of voting shares assigned to this member
         uint256 loot; // the loot amount available to this member (combined with shares on ragequit)
         uint256 iTokenAmts;
@@ -113,7 +131,7 @@ contract Party is ReentrancyGuard {
         uint256 startingPeriod; // the period in which voting can start for this proposal
         uint256 yesVotes; // the total number of YES votes for this proposal
         uint256 noVotes; // the total number of NO votes for this proposal
-        bool[7] flags; // [sponsored, processed, didPass, cancelled, guildkick, spending, member]
+        bool[8] flags; // [sponsored, processed, didPass, cancelled, guildkick, spending, member, action]
         bytes32 details; // proposal details to add context for members 
         uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal
         mapping(address => Vote) votesByMember; // the votes on this proposal by each member
@@ -129,6 +147,8 @@ contract Party is ReentrancyGuard {
 
     mapping(uint256 => Proposal) public proposals;
     uint256[] public proposalQueue;
+    mapping(uint256 => bytes) public actions; // proposalId => action data
+
     
     /******************
     SUMMONING FUNCTIONS
@@ -142,17 +162,18 @@ contract Party is ReentrancyGuard {
         uint256 _gracePeriodLength,
         uint256 _proposalDepositReward,
         uint256 _depositRate,
-        uint256 _partyGoal,
-        bytes32 _name,
-        bytes32 _desc
+        uint256 _partyGoal
     ) public {
+        require(!initialized, "initialized");
+        initialized = true;
         require(_periodDuration > 0, "_periodDuration zeroed");
         require(_votingPeriodLength > 0, "_votingPeriodLength zeroed");
         require(_votingPeriodLength <= MAX_INPUT, "_votingPeriodLength maxed");
         require(_gracePeriodLength <= MAX_INPUT, "_gracePeriodLength maxed");
         require(_approvedTokens.length > 0, "need token");
         
         depositToken = _approvedTokens[0];
+        //idleToken = _approvedTokens[1];
         // NOTE: move event up here, avoid stack too deep if too many approved tokens
         emit SummonComplete(_founders, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDepositReward, _depositRate, _partyGoal);
         
@@ -163,6 +184,10 @@ contract Party is ReentrancyGuard {
             approvedTokens.push(_approvedTokens[i]);
         }
         
+        for (uint256 i = 0; i < _founders.length; i++) {
+            _addFounder(_founders[i]);
+        }
+        
         daoFee = _daoFee;
         periodDuration = _periodDuration;
         votingPeriodLength = _votingPeriodLength;
@@ -171,91 +196,27 @@ contract Party is ReentrancyGuard {
         depositRate = _depositRate;
         partyGoal = _partyGoal;
         summoningTime = now;
-        name = _name;
-        desc = _desc;
-        status = NOT_SET;
+        goalHit = 0;
+        
+        _initReentrancyGuard();
+
         
-        _addFounders(_founders); //had to move to internal function to avoid stack to deep issue 
-        _setIdle(approvedTokens[1]);
     }
     
     /****************
     SUMMONING FUNCTIONS
     ****************/
     
-    function _addFounders(address[] memory _founders) internal nonReentrant {
-            for (uint256 i = 0; i < _founders.length; i++) {
-            members[_founders[i]] = Member(_founders[i], 0, 0, 0, 0, 0, false, false);
-            memberList.push(_founders[i]);
-        }
+   function _addFounder(address founder) internal {
+            members[founder] = Member(0, 0, 0, 0, 0, false, true);
+            memberList.push(founder);
     }
     
-    function _setIdle(address _idleToken) internal nonReentrant {
-        idleToken = IIdleToken(_idleToken);
+    // Can also be used to upgrade the idle contract, but not switch to new DeFi token (ie. iDAI to iUSDC)
+    function _setIdle(address _idleToken) internal {
+        idleToken = _idleToken;
     }
     
-    
-    function makeDeposit(address token, uint256 tribute) public nonReentrant {
-        require(members[msg.sender].exists == true, "not member");
-        require(tribute >= depositRate, "tribute insufficient");
-        require(token == depositToken, "can only deposit depositToken");
-        
-        uint256 shares = tribute.div(depositRate);
-        require(totalShares + shares <= MAX_INPUT, "shares maxed");
-        
-        if(memberList.length > 1) {
-        require((members[msg.sender].shares.add(shares)) != (totalShares.add(shares)).div(uint256(2)), "can't buy 50%+ shares without a proposal");
-        }
-        
-        members[msg.sender].shares += shares;
-        totalShares += shares;
-        
-        if (userTokenBalances[GUILD][depositToken] == 0 && tribute > 0) {
-            totalGuildBankTokens += 1;
-        }
-        
-        depositToIdle(msg.sender, token, tribute);
-        
-        emit MakeDeposit(msg.sender, tribute, shares);
-    }
-    
-    /****************
-    MINION GOVERNANCE
-    ****************/
-    
-    // NOTE: should be done programmatically so that it's the minion created w/ the contract
-    function setMinion(address _minion) public nonReentrant {
-        require(status != SET, "already set");
-        minion = _minion;
-        status = SET; // locks minion for moloch contract set on summoning
-    }
-    
-    function amendGovernance(
-        address _newToken,
-        address _idleToken,
-        address _minion,
-        uint256 _partyGoal,
-        uint256 _depositRate
-    ) external nonReentrant {
-        require(msg.sender == address(minion), "only minion can make these changes!");
-        
-        minion = _minion;
-        depositRate = _depositRate;
-        partyGoal = _partyGoal;
-        
-        if(_newToken != address(0)) {
-            require(totalGuildBankTokens < MAX_TOKEN_WHITELIST_COUNT, "too many tokens already");
-            require(!tokenWhitelist[address(_newToken)], "already whitelisted");
-            approvedTokens.push(_newToken);
-            totalGuildBankTokens += 1;
-        }
-        
-        if(_idleToken != address(0)) {
-            _setIdle(_idleToken);
-        }
-        
-        emit AmendGovernance(_newToken, minion, depositRate);
-    }
 
     /*****************
     PROPOSAL FUNCTIONS
@@ -272,36 +233,51 @@ contract Party is ReentrancyGuard {
         bytes32 details
     ) public nonReentrant returns (uint256 proposalId) {
         require(sharesRequested.add(lootRequested) <= MAX_INPUT, "shares maxed");
-        require(tokenWhitelist[paymentToken], "payment not whitelisted");
+        if(flagNumber != 7){
+            require(tokenWhitelist[tributeToken] && tokenWhitelist[paymentToken], "tokens not whitelisted");  
+        }
         require(applicant != address(0), "applicant cannot be 0");
         require(members[applicant].jailed == false, "applicant jailed");
-        require(userTokenBalances[GUILD][depositToken] >= partyGoal, "goal not met yet");
-        require(flagNumber != 0 || flagNumber != 1 || flagNumber != 2 || flagNumber != 3, "flag must be 4 - guildkick, 5 - spending, 6 - membership");
-
-        // collect tribute from proposer and store it in the Moloch until the proposal is processed
-        require(IERC20(paymentToken).transferFrom(msg.sender, address(this), proposalDepositReward), "proposal deposit failed");
+        require(flagNumber != 0 || flagNumber != 1 || flagNumber != 2 || flagNumber != 3, "flag must be 4 - guildkick, 5 - spending, 6 - membership, 7 - governance");
+        
+        // collect deposit from proposer
+        require(IERC20(depositToken).transferFrom(msg.sender, address(this), proposalDepositReward), "proposal deposit failed");
         unsafeAddToBalance(ESCROW, paymentToken, proposalDepositReward);
+        // collect tribute from proposer and store it in the Moloch until the proposal is processed
+        require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), "tribute token transfer failed");
+        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);
         
         // check whether pool goal is met before allowing spending proposals
         if(flagNumber == 5) {
-            require(userTokenBalances[GUILD][depositToken] >= partyGoal, "goal not met yet");
+            require(goalHit == 1, "goal not met yet");
         }
-
-        bool[7] memory flags; // [sponsored, processed, didPass, cancelled, guildkick, spending, member]
+        
+         if(flagNumber == 6) {
+            require(paymentRequested == 0 || goalHit == 1, "goal not met yet");
+        }
+        
+        bool[8] memory flags; // [sponsored, processed, didPass, cancelled, guildkick, spending, member, governance]
         flags[flagNumber] = true;
         
         if(flagNumber == 4) {
             _submitProposal(applicant, 0, 0, 0, address(0), 0, address(0), details, flags);
-        } else {
-            _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested,  paymentToken, details, flags);
-        }
+        } 
+        
+        else if (flagNumber == 7) { // for amend governance use tributeOffered for partyGoal, paymentRequested for depositRate, tributeToken for new Token, paymentToken for new idleToken
+            _submitProposal(applicant, 0, 0, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);
+        } 
+        
+        else {
+        
+        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);
 
+        }
         // NOTE: Should approve the 0x address as a blank token for guildKick proposals where there's no token. 
         return proposalCount - 1; // return proposalId - contracts calling submit might want it
     }
     
 
-function _submitProposal(
+   function _submitProposal(
         address applicant,
         uint256 sharesRequested,
         uint256 lootRequested,
@@ -310,7 +286,7 @@ function _submitProposal(
         uint256 paymentRequested,
         address paymentToken,
         bytes32 details,
-        bool[7] memory flags
+        bool[8] memory flags
     ) internal {
         Proposal memory proposal = Proposal({
             applicant : applicant,
@@ -329,23 +305,28 @@ function _submitProposal(
             details : details,
             maxTotalSharesAndLootAtYesVote : 0
         });
-
+        
         proposals[proposalCount] = proposal;
+        address memberAddress = msg.sender;
         // NOTE: argument order matters, avoid stack too deep
-        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, proposalCount, msg.sender);
+        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, proposalCount, msg.sender, memberAddress);
         proposalCount += 1;
     }
 
-    
     function sponsorProposal(uint256 proposalId) public nonReentrant  {
+
         Proposal storage proposal = proposals[proposalId];
-        require(members[msg.sender].exists == true, "must be a member to sponsor");
+
         require(proposal.proposer != address(0), 'proposal must have been proposed');
         require(!proposal.flags[0], "proposal has already been sponsored");
         require(!proposal.flags[3], "proposal has been cancelled");
+        require(members[proposal.applicant].jailed == false, "proposal applicant must not be jailed");
+
+        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {
+            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, 'cannot sponsor more tribute proposals for new tokens - guildbank is full');
+        }
 
-        // guild kick proposal
-        if (proposal.flags[4]) { //  [sponsored, processed, didPass, cancelled, guildkick, spending, member]
+         if (proposal.flags[4]) {
             require(!proposedToKick[proposal.applicant], 'already proposed to kick');
             proposedToKick[proposal.applicant] = true;
         }
@@ -357,37 +338,35 @@ function _submitProposal(
         ).add(1);
 
         proposal.startingPeriod = startingPeriod;
-        
-        proposal.sponsor = msg.sender;
+
+        address memberAddress = msg.sender;
+        proposal.sponsor = memberAddress;
 
         proposal.flags[0] = true; // sponsored
 
         // append proposal to the queue
         proposalQueue.push(proposalId);
         
-        emit SponsorProposal(msg.sender, proposalId, proposalQueue.length.sub(1), startingPeriod);
+        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length.sub(1), startingPeriod);
     }
 
 
-
-    // NOTE: In PoolParty proposalId = proposalIndex +1 since sponsorship is auto. 
-    function submitVote(uint256 proposalIndex, uint8 uintVote) public nonReentrant  {
-        address memberAddress = msg.sender;
-        Member storage member = members[memberAddress];
+    function submitVote(uint256 proposalIndex, uint8 uintVote) public nonReentrant {
+        require(members[msg.sender].exists == true);
+        Member storage member = members[msg.sender];
 
         require(proposalIndex < proposalQueue.length, "proposal does not exist");
-        require(members[memberAddress].exists == true, "must be a member to vote");
         Proposal storage proposal = proposals[proposalQueue[proposalIndex]];
 
-        require(uintVote < 3, "must be less than 3, 0 = yes, 1 = no");
+        require(uintVote < 3, "must be less than 3, 1 = yes, 2 = no");
         Vote vote = Vote(uintVote);
 
         require(getCurrentPeriod() >= proposal.startingPeriod, "voting period has not started");
         require(!hasVotingPeriodExpired(proposal.startingPeriod), "proposal voting period has expired");
-        require(proposal.votesByMember[memberAddress] == Vote.Null, "member has already voted");
+        require(proposal.votesByMember[msg.sender] == Vote.Null, "member has already voted");
         require(vote == Vote.Yes || vote == Vote.No, "vote must be either Yes or No");
 
-        proposal.votesByMember[memberAddress] = vote;
+        proposal.votesByMember[msg.sender] = vote;
 
         if (vote == Vote.Yes) {
             proposal.yesVotes = proposal.yesVotes.add(member.shares);
@@ -406,17 +385,19 @@ function _submitProposal(
             proposal.noVotes = proposal.noVotes.add(member.shares);
         }
      
-        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);
+        emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, msg.sender, uintVote);
     }
 
     function processProposal(uint256 proposalIndex) public nonReentrant {
         _validateProposalForProcessing(proposalIndex);
 
-        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];
-
-        require(!proposal.flags[3], "not standard proposal"); 
+        uint256 proposalId = proposalQueue[proposalIndex];
+        Proposal storage proposal = proposals[proposalId];
+        
+        //[sponsored -0 , processed -1, didPass -2, cancelled -3, guildkick -4, spending -5, member -6, action -7]
+        require(!proposal.flags[4], "not standard proposal"); 
 
-        proposal.flags[0] = true; // processed
+        proposal.flags[1] = true; // processed
 
         bool didPass = _didPass(proposalIndex);
 
@@ -426,13 +407,13 @@ function _submitProposal(
         }
 
         // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance
-        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {
+        if (proposal.paymentToken != depositToken && proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {
             didPass = false;
         }
 
         // PROPOSAL PASSED
         if (didPass) {
-            proposal.flags[1] = true; // didPass
+            proposal.flags[2] = true; // didPass
 
             // if the applicant is already a member, add to their existing shares & loot
             if (members[proposal.applicant].exists) {
@@ -442,59 +423,69 @@ function _submitProposal(
             // the applicant is a new member, create a new record for them
             } else {
 
-                // use applicant address as delegateKey by default
-                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, proposal.lootRequested, 0, 0, 0, false, true);
+                members[proposal.applicant] = Member(proposal.sharesRequested, proposal.lootRequested, 0, 0, 0, false, true);
                 memberList.push(proposal.applicant);
             }
 
             // mint new shares & loot
             totalShares = totalShares.add(proposal.sharesRequested);
             totalLoot = totalLoot.add(proposal.lootRequested);
 
-            // if the proposal tribute is the first tokens of its kind to make it into the guild bank, increment total guild bank tokens
-            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {
-                totalGuildBankTokens += 1;
-            }
-
-            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);
-            if (proposal.tributeToken == depositToken) {
-                depositToIdle(proposal.applicant, proposal.tributeToken, proposal.tributeOffered);
-            }
+             if (proposal.tributeToken == depositToken && proposal.tributeOffered > 0) {
+                 unsafeSubtractFromBalance(ESCROW, proposal.tributeToken, proposal.tributeOffered);
+                 depositToIdle(proposal.applicant, proposal.tributeOffered, proposal.sharesRequested);
+             } else {
+               unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);
+             }
+            
+             if (proposal.paymentToken == address(idleToken)) {
+                 uint256 proposalPayment = subFees(GUILD, proposal.paymentRequested);
+                 unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposalPayment);
+             }
+            
+             if (proposal.paymentToken == depositToken && proposal.paymentRequested > 0 ){
+                uint256 iTokenPrice = IIdleToken(idleToken).tokenPrice();
+                uint256 idleToConvert = proposal.paymentRequested.div(iTokenPrice);
+                uint256 idleRedemptionAmt = subFees(GUILD, idleToConvert);
+                
+                if(idleRedemptionAmt > userTokenBalances[GUILD][address(idleToken)]){
+                    proposal.flags[2] = false;
+                }
+                
+                uint256 depositTokenAmt = IIdleToken(idleToken).redeemIdleToken(idleRedemptionAmt);
+                unsafeAddToBalance(proposal.applicant, proposal.paymentToken, depositTokenAmt);
+                
+                emit ProcessIdleProposal(proposalIndex, proposalId, idleRedemptionAmt, depositTokenAmt);
+             }
             
             unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);
 
-            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens
-            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {
-                totalGuildBankTokens -= 1;
-            }
-
         // PROPOSAL FAILED
         } else {
             // return all tokens to the proposer (not the applicant, because funds come from proposer)
             unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);
         }
 
         _returnDeposit();
-
-        emit ProcessProposal(proposalIndex, didPass);
+        
+        emit ProcessProposal(proposalIndex, proposalId, didPass);
     }
 
-    
 
     function processGuildKickProposal(uint256 proposalIndex) public nonReentrant {
         _validateProposalForProcessing(proposalIndex);
 
         uint256 proposalId = proposalQueue[proposalIndex];
         Proposal storage proposal = proposals[proposalId];
 
-        require(proposal.flags[3], "not guild kick");
+        require(proposal.flags[4], "not guild kick");
 
-        proposal.flags[0] = true; //[processed, didPass, cancelled, guildkick, spending, member]
+        proposal.flags[1] = true; //[sponsored, processed, didPass, cancelled, guildkick, spending, member]
 
         bool didPass = _didPass(proposalIndex);
 
         if (didPass) {
-            proposal.flags[1] = true; // didPass
+            proposal.flags[2] = true; // didPass
             Member storage member = members[proposal.applicant];
             member.jailed == true;
 
@@ -511,6 +502,51 @@ function _submitProposal(
 
         emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);
     }
+    
+    function processAmendGovernance(uint256 proposalIndex) public nonReentrant {
+        _validateProposalForProcessing(proposalIndex);
+
+        uint256 proposalId = proposalQueue[proposalIndex];
+        Proposal storage proposal = proposals[proposalId];
+
+        require(proposal.flags[7], "not gov amendment");
+
+        proposal.flags[1] = true; //[sponsored, processed, didPass, cancelled, guildkick, spending, member]
+
+        bool didPass = _didPass(proposalIndex);
+
+            if (didPass) {
+                proposal.flags[2] = true; // didPass
+            
+            // Updates PartyGoal
+            if(proposal.tributeOffered > 0){
+                partyGoal = proposal.tributeOffered;
+            }
+            
+            // Update depositRate
+            if(proposal.paymentRequested > 0){
+                depositRate = proposal.paymentRequested;
+            }
+            
+            // Adds token to whitelist and approvedTokens
+            if(proposal.tributeToken != address(0)){
+                require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, "too many tokens already");
+                approvedTokens.push(proposal.tributeToken);
+                tokenWhitelist[address(proposal.tributeToken)] = true;
+            }
+            // Used to upgrade iToken, cannot be used to switch iToken since depositToken is static
+            if(proposal.paymentToken != address(0)){
+                _setIdle(proposal.paymentToken);
+                approvedTokens.push(proposal.paymentToken);
+                tokenWhitelist[address(proposal.tributeToken)] = true;
+            }
+        }
+
+        _returnDeposit();
+        
+        emit ProcessAmendGovernance(proposalIndex, proposalId, didPass, proposal.tributeToken, proposal.paymentToken, proposal.tributeOffered, proposal.paymentRequested);
+    }
+    
 
     function _didPass(uint256 proposalIndex) internal view returns (bool didPass) {
         Proposal memory proposal = proposals[proposalQueue[proposalIndex]];
@@ -525,7 +561,7 @@ function _submitProposal(
         // Make the proposal fail if the applicant is jailed
         // - for standard proposals, we don't want the applicant to get any shares/loot/payment
         // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter
-        if (members[proposal.applicant].jailed != true) {
+        if (members[proposal.applicant].jailed == true) {
             didPass = false;
         }
 
@@ -537,8 +573,8 @@ function _submitProposal(
         Proposal memory proposal = proposals[proposalQueue[proposalIndex]];
 
         require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), "proposal not ready");
-        require(proposal.flags[0] == false, "proposal has already been processed");
-        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex.sub(1)]].flags[0], "previous proposal unprocessed");
+        require(proposal.flags[1] == false, "proposal has already been processed");
+        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex.sub(1)]].flags[1], "previous proposal unprocessed");
     }
 
     function _returnDeposit() internal {
@@ -574,12 +610,15 @@ function _submitProposal(
             if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit
                 userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;
                 userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;
-                
-                if(member.iTokenRedemptions > 0) {
-                    uint256 iTokenAdj = member.iTokenRedemptions;
-                    unsafeInternalTransfer(memberAddress, GUILD, address(idleToken), iTokenAdj); 
-                    member.iTokenRedemptions.add(amountToRagequit.sub(iTokenAdj));  
-                }
+                uint256 idleForFee = userTokenBalances[memberAddress][address(idleToken)].sub(member.iTokenRedemptions);
+                subFees(memberAddress, idleForFee);
+ 
+                 if(member.iTokenRedemptions > 0) {
+                     uint256 idleAdj = member.iTokenRedemptions;
+                     unsafeInternalTransfer(memberAddress, GUILD, address(idleToken), idleAdj);
+                 }
+                 
+                member.iTokenRedemptions.add(idleForFee); 
             }
         }
 
@@ -595,28 +634,35 @@ function _submitProposal(
 
         _ragequit(memberToKick, 0, member.loot);
     }
-
-    function withdrawBalance(address token, uint256 amount) public nonReentrant {
-        _withdrawBalance(token, amount);
-    }
     
-    function withdrawInterest(address memberAddress) public nonReentrant {
-        require(members[memberAddress].exists == true, "not member");
+    function withdrawEarnings(address memberAddress, uint256 amount) external nonReentrant {
+        
+        Member storage member = members[memberAddress];
+        
+        require(member.exists == true, "not member");
         require(address(msg.sender) == memberAddress, "can only be called by member");
         
-        uint256 earnings = getUserEarnings(msg.sender);
-        uint256 iTokenPrice = IIdleToken(idleToken).tokenPrice();
-        uint256 earningsTokens = earnings.div(iTokenPrice);
         
-        require(earningsTokens > 0, "not enough earnings to redeem a token");
-        members[memberAddress].iTokenRedemptions.add(earningsTokens);
-    
-        uint256 redeemedTokens = idleToken.redeemIdleToken(earningsTokens, false, new uint256[](0));
+        uint256 earnings = getUserEarnings(member.iTokenAmts);
+        require(earnings.sub(member.iTokenRedemptions) >= amount, "not enough earnings to redeem this many tokens");
+        
+        uint256 earningsToUser = subFees(GUILD, amount);
+        uint256 redeemedTokens = IIdleToken(idleToken).redeemIdleToken(earningsToUser);
+        
+        member.iTokenRedemptions.add(earningsToUser);
         // @DEV - see if we need to run a collectTokens function to collect the DAI and move to GUILD
         unsafeAddToBalance(GUILD, depositToken, redeemedTokens);
-        unsafeInternalTransfer(GUILD, msg.sender, depositToken, redeemedTokens);
+        unsafeInternalTransfer(GUILD, memberAddress, depositToken, redeemedTokens);
+        
         _withdrawBalance(depositToken, redeemedTokens);
+        
+        emit WithdrawEarnings(msg.sender, earningsToUser, redeemedTokens);
+    }
+
+    function withdrawBalance(address token, uint256 amount) public nonReentrant {
+        _withdrawBalance(token, amount);
     }
+    
 
     function withdrawBalances(address[] memory tokens, uint256[] memory amounts, bool max) public nonReentrant {
         require(tokens.length == amounts.length, "tokens + amounts arrays must match");
@@ -639,18 +685,6 @@ function _submitProposal(
         emit Withdraw(msg.sender, token, amount);
     }
     
-    function withdrawFees() external {
-        
-        uint256 totalEarnings = getGuildEarnings();
-        // Pool Fees = 20% of interest (i.e. if interest earnings = 5% then pool fees are 1%)
-        uint256 poolFees = totalEarnings.mul(uint256(100).div(20));
-        uint256 iTokenPrice = IIdleToken(idleToken).tokenPrice();
-        uint256 feeTokens = poolFees.div(iTokenPrice);
-        
-        require(feeTokens > 1*10**18, "not enough fees to withdraw");
-        require(IERC20(address(idleToken)).transfer(daoFee, feeTokens));
-        unsafeSubtractFromBalance(GUILD, address(idleToken), feeTokens);
-    }
 
     // NOTE: gives the DAO the ability to collect payments and also recover tokens just sent to DAO address (if whitelisted)
     function collectTokens(address token) external {
@@ -659,16 +693,12 @@ function _submitProposal(
         require(amountToCollect > 0, "no tokens");
         require(tokenWhitelist[token], "not whitelisted");
         
-        if (userTokenBalances[GUILD][token] == 0 && totalGuildBankTokens < MAX_TOKEN_WHITELIST_COUNT) {
-            totalGuildBankTokens += 1;
-        }
         unsafeAddToBalance(GUILD, token, amountToCollect);
 
         emit TokensCollected(token, amountToCollect);
     }
     
 
-    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender == proposal.proposer
     function cancelProposal(uint256 proposalId) public nonReentrant {
         Proposal storage proposal = proposals[proposalId];
         require(getCurrentPeriod() <= proposal.startingPeriod, "voting period has already started");
@@ -681,11 +711,14 @@ function _submitProposal(
         emit CancelProposal(proposalId, msg.sender);
     }
 
-
     // can only ragequit if the latest proposal you voted YES on has been processed
     function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {
-        require(highestIndexYesVote < proposalQueue.length, "no such proposal");
-        return proposals[proposalQueue[highestIndexYesVote]].flags[0];
+        if(proposalQueue.length == 0){
+            return true;
+        } else {
+            require(highestIndexYesVote < proposalQueue.length, "no such proposal");
+            return proposals[proposalQueue[highestIndexYesVote]].flags[0];
+        }
     }
 
     function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {
@@ -707,7 +740,7 @@ function _submitProposal(
         return proposalQueue.length;
     }
 
-    function getProposalFlags(uint256 proposalId) public view returns (bool[7] memory) {
+    function getProposalFlags(uint256 proposalId) public view returns (bool[8] memory) {
         return proposals[proposalId].flags;
     }
 
@@ -729,36 +762,70 @@ function _submitProposal(
     HELPER FUNCTIONS
     ***************/
     
-    function getUserEarnings(address memberAddress) public returns (uint256) {
-        uint256 userBalance = members[memberAddress].iTokenAmts.sub(members[memberAddress].iTokenRedemptions);
+    function getUserEarnings(uint256 amount) public returns (uint256) {
+        uint256 userBalance = amount;
         uint256 avgCost = userBalance.mul(IIdleToken(idleToken).userAvgPrices(address(this))).div(10**18);
         uint256 currentValue = userBalance.mul(IIdleToken(idleToken).tokenPrice()).div(10**18);
-        uint256 totalEarnings = currentValue.sub(avgCost);
-        uint256 poolFees = totalEarnings.mul(uint256(100).div(20));
-        uint256 earnings = totalEarnings.sub(poolFees);
+        uint256 earnings = currentValue.sub(avgCost);
 
         return earnings;
     }
     
-    // *NOTE* - returns earnings inclusive of fees 
-    function getGuildEarnings() public returns (uint256) {
-        address user = address(this);
-        uint256 userBalance = getUserTokenBalance(GUILD, address(idleToken));
-        uint256 avgCost = userBalance.mul(idleToken.userAvgPrices(user)).div(10**18);
-        uint256 currentValue = userBalance.mul(idleToken.tokenPrice()).div(10**18);
-        uint256 totalEarnings = currentValue.sub(avgCost);
+    function getUserIdleBalance(address user) external view returns (uint256){
+        return members[user].iTokenAmts.sub(members[user].iTokenRedemptions);
+    }
+    
+    function getIdleValue(uint256 amount) public view returns (uint256){
+        return amount.mul(IIdleToken(idleToken).tokenPrice()).div(10**18);
+    }
+    
+    function subFees(address holder, uint256 amount) internal returns (uint256) {
+        uint256 poolFees = amount.div(uint256(100).div(10));
+        unsafeInternalTransfer(holder, daoFee, address(idleToken), poolFees);
+        return amount.sub(poolFees);
+    }
+    
+    function makeDeposit(uint256 amount) external nonReentrant {
+        require(members[msg.sender].exists == true, 'must be member to deposit shares');
+        
+        uint256 shares = amount.div(depositRate);
+        members[msg.sender].shares += shares;
+        require(members[msg.sender].shares <= partyGoal.div(depositRate).div(2), "can't take over 50% of the shares w/o a proposal");
+        totalShares += shares;
         
-        return totalEarnings;
+        require(IERC20(depositToken).transferFrom(msg.sender, address(this), amount), "token transfer failed");
+        depositToIdle(msg.sender, amount, shares);
     }
     
-    function depositToIdle(address depositor, address token, uint256 amount) internal {
-        require(token == depositToken, "not able to deposit in idle");
+    
+    function depositToIdle(address depositor, uint256 amount, uint256 shares) internal {
         require(amount != 0, "no tokens to deposit");
-        require(IERC20(address(idleToken)).approve(address(this), amount), 'approval failed');
+        totalDeposits += amount;
+        
+        // Token is the deposit token (eg. DAI)
+        require(IERC20(depositToken).approve(address(idleToken), amount), 'approval failed');
+        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(amount, true, depositor);
+        members[depositor].iTokenAmts += mintedTokens;
+        unsafeAddToBalance(GUILD, idleToken, mintedTokens);
+        
+        // Checks to see if goal has been reached with this deposit
+         goalHit = checkGoal();
         
-        uint256 newIdle = IIdleToken(idleToken).mintIdleToken(amount, true);
-        unsafeAddToBalance(GUILD, address(idleToken), newIdle);
-        members[depositor].iTokenAmts.add(newIdle);
+        // @Dev updates here b/c solidity doesn't recognize as a view only function
+        idleAvgCost = IIdleToken(idleToken).userAvgPrices(address(this));
+        
+        emit MakeDeposit(depositor, amount, mintedTokens, shares, idleAvgCost, goalHit);
+    }
+    
+    function checkGoal() public returns (uint8) {
+        uint256 daoFunds = getUserTokenBalance(GUILD, idleToken);
+        uint256 idleValue = getIdleValue(daoFunds);
+        
+        if(idleValue >= partyGoal){
+            goalHit = 1;
+        } else {
+            goalHit = 0;
+        }
     }
     
     
@@ -789,5 +856,5 @@ function _submitProposal(
         }
 
         return (balance / totalSharesAndLoot) * shares;
-    }  
-}
\ No newline at end of file
+    } 
+}    
\ No newline at end of file