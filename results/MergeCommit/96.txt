@@ -2,17 +2,16 @@
 pragma solidity 0.8.10;
 
 import {ERC20} from "solmate/tokens/ERC20.sol";
+import {ERC4626} from "solmate/mixins/ERC4626.sol";
 import {Auth, Authority} from "solmate/auth/Auth.sol";
 import {SafeTransferLib} from "solmate/utils/SafeTransferLib.sol";
 
-import {ERC4626} from "solmate/mixins/ERC4626.sol";
-
 import {FuseAdmin} from "./interfaces/FuseAdmin.sol";
 import {Comptroller} from "./interfaces/Comptroller.sol";
 
+import {TurboClerk} from "./modules/TurboClerk.sol";
 import {TurboGibber} from "./modules/TurboGibber.sol";
 import {TurboBooster} from "./modules/TurboBooster.sol";
-import {TurboClerk} from "./modules/TurboClerk.sol";
 
 import {TurboSafe} from "./TurboSafe.sol";
 
@@ -96,26 +95,6 @@ contract TurboMaster is Auth {
         emit ClerkUpdated(msg.sender, newClerk);
     }
 
-    /*///////////////////////////////////////////////////////////////
-                            GIBBER STORAGE
-    //////////////////////////////////////////////////////////////*/
-
-    /// @notice The Gibber module used by the Master and its Safes.
-    TurboGibber public gibber;
-
-    /// @notice Emitted when the Gibber is updated.
-    /// @param user The user who triggered the update of the Gibber.
-    /// @param newGibber The new Gibber contract used by the Master.
-    event GibberUpdated(address indexed user, TurboGibber newGibber);
-
-    /// @notice Update the Gibber used by the Master.
-    /// @param newGibber The new Gibber contract to be used by the Master.
-    function setGibber(TurboGibber newGibber) external requiresAuth {
-        gibber = newGibber;
-
-        emit GibberUpdated(msg.sender, newGibber);
-    }
-
     /*///////////////////////////////////////////////////////////////
                   DEFAULT SAFE AUTHORITY CONFIGURATION
     //////////////////////////////////////////////////////////////*/
@@ -144,7 +123,7 @@ contract TurboMaster is Auth {
     /// @notice The total Fei currently boosting Vaults.
     uint256 public totalBoosted;
 
-    /// @notice Maps Safe addresses to the id they are stored under in the safes array.
+    /// @notice Maps Safe addresses to the id they are stored under in the Safes array.
     mapping(TurboSafe => uint256) public getSafeId;
 
     /// @notice Maps Vault addresses to the total amount of Fei they've being boosted with.
@@ -154,6 +133,7 @@ contract TurboMaster is Auth {
     mapping(ERC20 => uint256) public getTotalBoostedAgainstCollateral;
 
     /// @notice An array of all Safes created by the Master.
+    /// @dev The first Safe is purposely invalid to prevent any Safes from having an id of 0.
     TurboSafe[] public safes;
 
     /// @notice Returns all Safes created by the Master.
@@ -170,17 +150,17 @@ contract TurboMaster is Auth {
 
     /// @notice Emitted when a new Safe is created.
     /// @param user The user who created the Safe.
-    /// @param underlying The underlying token of the Safe.
+    /// @param asset The asset of the Safe.
     /// @param safe The newly deployed Safe contract.
     /// @param id The index of the Safe in the safes array.
-    event TurboSafeCreated(address indexed user, ERC20 indexed underlying, TurboSafe safe, uint256 id);
+    event TurboSafeCreated(address indexed user, ERC20 indexed asset, TurboSafe safe, uint256 id);
 
-    /// @notice Creates a new Turbo Safe which supports a specific underlying token.
-    /// @param underlying The ERC20 token that the Safe should accept.
-    /// @return safe The newly deployed Turbo Safe which accepts the provided underlying token.
-    function createSafe(ERC20 underlying) external requiresAuth returns (TurboSafe safe, uint256 id) {
-        // Create a new Safe using the default authority and provided underlying token.
-        safe = new TurboSafe(msg.sender, defaultSafeAuthority, underlying);
+    /// @notice Creates a new Turbo Safe which supports a specific asset.
+    /// @param asset The ERC20 token that the Safe should accept.
+    /// @return safe The newly deployed Turbo Safe which accepts the provided asset.
+    function createSafe(ERC20 asset) external requiresAuth returns (TurboSafe safe, uint256 id) {
+        // Create a new Safe using the default authority and provided asset.
+        safe = new TurboSafe(msg.sender, defaultSafeAuthority, asset);
 
         // Add the safe to the list of Safes.
         safes.push(safe);
@@ -194,7 +174,7 @@ contract TurboMaster is Auth {
         // Store the id/index of the new Safe.
         getSafeId[safe] = id;
 
-        emit TurboSafeCreated(msg.sender, underlying, safe, id);
+        emit TurboSafeCreated(msg.sender, asset, safe, id);
 
         // Prepare a users array to whitelist the Safe.
         address[] memory users = new address[](1);
@@ -213,11 +193,11 @@ contract TurboMaster is Auth {
     //////////////////////////////////////////////////////////////*/
 
     /// @notice Callback triggered whenever a Safe boosts a Vault.
-    /// @param underlying The underlying token of the Safe.
+    /// @param asset The asset of the Safe.
     /// @param vault The Vault that was boosted.
     /// @param feiAmount The amount of Fei used to boost the Vault.
     function onSafeBoost(
-        ERC20 underlying,
+        ERC20 asset,
         ERC4626 vault,
         uint256 feiAmount
     ) external {
@@ -227,45 +207,47 @@ contract TurboMaster is Auth {
         // Ensure the Safe was created by this Master.
         require(getSafeId[safe] != 0, "INVALID_SAFE");
 
-        // Compute the total amount of Fei that will be boosting the Vault.
-        uint256 newTotalBoostedForVault = getTotalBoostedForVault[vault] + feiAmount;
+        // Update the total amount of Fei being using to boost Vaults.
+        totalBoosted += feiAmount;
+
+        // Cache the new total boosted for the Vault.
+        uint256 newTotalBoostedForVault;
+
+        // Cache the new total boosted against the Vault's collateral.
+        uint256 newTotalBoostedAgainstCollateral;
+
+        unchecked {
+            // Update the total amount of Fei being using to boost the Vault.
+            // Cannot overflow because a Safe's total will never be greater than global total.
+            getTotalBoostedForVault[vault] = (newTotalBoostedForVault = getTotalBoostedForVault[vault] + feiAmount);
 
-        // Compute the total amount of Fei boosted that will be boosted the Safe's collateral type.
-        uint256 newTotalBoostedAgainstCollateral = getTotalBoostedAgainstCollateral[underlying] + feiAmount;
+            // Update the total amount of Fei boosted against the collateral type.
+            // Cannot overflow because a collateral type's total will never be greater than global total.
+            getTotalBoostedAgainstCollateral[asset] = (newTotalBoostedAgainstCollateral =
+                getTotalBoostedAgainstCollateral[asset] +
+                feiAmount);
+        }
 
         // Check with the booster that the Safe is allowed to boost the Vault using this amount of Fei.
         require(
             booster.canSafeBoostVault(
                 safe,
-                underlying,
+                asset,
                 vault,
                 feiAmount,
                 newTotalBoostedForVault,
                 newTotalBoostedAgainstCollateral
             ),
             "BOOSTER_REJECTED"
         );
-
-        // Update the total amount of Fei being using to boost Vaults.
-        totalBoosted += feiAmount;
-
-        unchecked {
-            // Update the total amount of Fei being using to boost the Vault.
-            // Cannot overflow because a Safe's total will never be greater than global total.
-            getTotalBoostedForVault[vault] = newTotalBoostedForVault;
-
-            // Update the total amount of Fei boosted against the collateral type.
-            // Cannot overflow because a collateral type's total will never be greater than global total.
-            getTotalBoostedAgainstCollateral[underlying] = newTotalBoostedAgainstCollateral;
-        }
     }
 
     /// @notice Callback triggered whenever a Safe withdraws from a Vault.
-    /// @param underlying The underlying token of the Safe.
+    /// @param asset The asset of the Safe.
     /// @param vault The Vault that was withdrawn from.
     /// @param feiAmount The amount of Fei withdrawn from the Vault.
     function onSafeLess(
-        ERC20 underlying,
+        ERC20 asset,
         ERC4626 vault,
         uint256 feiAmount
     ) external {
@@ -286,7 +268,36 @@ contract TurboMaster is Auth {
 
             // Update the total amount of Fei boosted against the collateral type.
             // Cannot underflow as the Safe validated the withdrawal amount previously.
-            getTotalBoostedAgainstCollateral[underlying] -= feiAmount;
+            getTotalBoostedAgainstCollateral[asset] -= feiAmount;
+        }
+    }
+
+    /// @notice Callback triggered whenever a Safe harvests from a Vault.
+    /// @param asset The asset of the Safe.
+    /// @param vault The Vault that was harvested from.
+    /// @param feiAmount The amount of Fei accrued as interest to the Safe.
+    function onSafeSlurp(
+        ERC20 asset,
+        ERC4626 vault,
+        uint256 feiAmount
+    ) external {
+        // Get the caller as a Safe instance.
+        TurboSafe safe = TurboSafe(msg.sender);
+
+        // Ensure the Safe was created by this Master.
+        require(getSafeId[safe] != 0, "INVALID_SAFE");
+
+        // Update the total amount of Fei being using to boost Vaults.
+        totalBoosted += feiAmount;
+
+        unchecked {
+            // Update the total amount of Fei being using to boost the Vault.
+            // Cannot overflow because a Safe's total will never be greater than global total.
+            getTotalBoostedForVault[vault] += feiAmount;
+
+            // Update the total amount of Fei boosted against the collateral type.
+            // Cannot overflow because a collateral type's total will never be greater than global total.
+            getTotalBoostedAgainstCollateral[asset] += feiAmount;
         }
     }
 