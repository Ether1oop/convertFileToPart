@@ -1,5 +1,5 @@
+
 // SPDX-License-Identifier: MIT
-// solhint-disable max-states-count
 
 pragma solidity 0.6.11;
 pragma experimental ABIEncoderV2;
@@ -17,10 +17,8 @@ import {PausableUpgradeable as Pausable} from "@openzeppelin/contracts-upgradeab
 import {ReentrancyGuardUpgradeable as ReentrancyGuard} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
 import "../interfaces/events/Destinations.sol";
 import "../interfaces/events/BalanceUpdateEvent.sol";
-import "../interfaces/IDelegateFunction.sol";
-import "../interfaces/events/IEventSender.sol";
 
-contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard, IEventSender {
+contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard {
     using SafeMath for uint256;
     using SafeERC20 for IERC20;
     using EnumerableSet for EnumerableSet.UintSet;
@@ -32,7 +30,7 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
 
     uint256 public withheldLiquidity;
     //userAddress -> withdrawalInfo
-    mapping(address => WithdrawalInfo) public requestedWithdrawals; // DEPRECATED
+    mapping(address => WithdrawalInfo) public requestedWithdrawals;
 
     //userAddress -> -> scheduleIndex -> staking detail
     mapping(address => mapping(uint256 => StakingDetails)) public userStakings;
@@ -53,33 +51,21 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
     bool public _eventSend;
     Destinations public destinations;
 
-    IDelegateFunction public delegateFunction; //DEPRECATED
-
-    // ScheduleIdx => notional address
-    mapping(uint256 => address) public notionalAddresses;
-    // address -> scheduleIdx -> WithdrawalInfo
-    mapping(address => mapping(uint256 => WithdrawalInfo)) public withdrawalRequestsByIndex;
-
-    address public override transferApprover;
-
-    mapping(address => mapping(uint256 => QueuedTransfer)) public queuedTransfers;
-
     modifier onlyPermissionedDepositors() {
         require(_isAllowedPermissionedDeposit(), "CALLER_NOT_PERMISSIONED");
         _;
     }
 
     modifier onEventSend() {
-        if (_eventSend) {
+        if(_eventSend) {
             _;
         }
     }
 
     function initialize(
         IERC20 _tokeToken,
         IManager _manager,
-        address _treasury,
-        address _scheduleZeroNotional
+        address _treasury
     ) public initializer {
         __Context_init_unchained();
         __Ownable_init_unchained();
@@ -104,17 +90,12 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
                 isActive: true,
                 hardStart: 0,
                 isPublic: true
-            }),
-            _scheduleZeroNotional
+            })
         );
     }
 
-    function addSchedule(StakingSchedule memory schedule, address notional)
-        external
-        override
-        onlyOwner
-    {
-        _addSchedule(schedule, notional);
+    function addSchedule(StakingSchedule memory schedule) external override onlyOwner {
+        _addSchedule(schedule);
     }
 
     function setPermissionedDepositor(address account, bool canDeposit)
@@ -123,8 +104,6 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         onlyOwner
     {
         permissionedDepositors[account] = canDeposit;
-
-        emit PermissionedDepositorSet(account, canDeposit);
     }
 
     function setUserSchedules(address account, uint256[] calldata userSchedulesIdxs)
@@ -133,8 +112,6 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         onlyOwner
     {
         userStakingSchedules[account] = userSchedulesIdxs;
-
-        emit UserSchedulesSet(account, userSchedulesIdxs);
     }
 
     function getSchedules()
@@ -153,6 +130,15 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         }
     }
 
+    function removeSchedule(uint256 scheduleIndex) external override onlyOwner {
+        require(scheduleIdxs.contains(scheduleIndex), "INVALID_SCHEDULE");
+
+        scheduleIdxs.remove(scheduleIndex);
+        delete schedules[scheduleIndex];
+
+        emit ScheduleRemoved(scheduleIndex);
+    }
+
     function getStakes(address account)
         external
         view
@@ -162,23 +148,6 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         stakes = _getStakes(account);
     }
 
-    function setNotionalAddresses(uint256[] calldata scheduleIdxArr, address[] calldata addresses)
-        external
-        override
-        onlyOwner
-    {
-        require(scheduleIdxArr.length == addresses.length, "MISMATCH_LENGTH");
-        for (uint256 i = 0; i < scheduleIdxArr.length; i++) {
-            uint256 currentScheduleIdx = scheduleIdxArr[i];
-            address currentAddress = addresses[i];
-            require(scheduleIdxs.contains(currentScheduleIdx), "INDEX_DOESNT_EXIST");
-            require(currentAddress != address(0), "INVALID_ADDRESS");
-
-            notionalAddresses[currentScheduleIdx] = currentAddress;
-        }
-        emit NotionalAddressesSet(scheduleIdxArr, addresses);
-    }
-
     function balanceOf(address account) public view override returns (uint256 value) {
         value = 0;
         uint256 scheduleCount = userStakingSchedules[account].length;
@@ -193,58 +162,6 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         }
     }
 
-    function sweepToScheduleZero(uint256 scheduleIdx, uint256 amount)
-        external
-        override
-        whenNotPaused
-        nonReentrant
-    {
-        require(amount > 0, "INVALID_AMOUNT");
-
-        require(scheduleIdxs.contains(scheduleIdx), "INVALID_INDEX");
-        require(_vested(msg.sender, scheduleIdx) >= amount, "INVALID_AMOUNT");
-
-        StakingDetails memory stakeFrom = userStakings[msg.sender][scheduleIdx];
-        StakingDetails memory stakeTo = userStakings[msg.sender][0];
-
-        // Add 0 to userStakingSchedules
-        if (stakeTo.started == 0) {
-            userStakingSchedules[msg.sender].push(0);
-            //solhint-disable-next-line not-rely-on-time
-            stakeTo.started = block.timestamp;
-        }
-        stakeFrom.withdrawn = stakeFrom.withdrawn.add(amount);
-        stakeTo.initial = stakeTo.initial.add(amount);
-
-        userStakings[msg.sender][scheduleIdx] = stakeFrom;
-        userStakings[msg.sender][0] = stakeTo;
-
-        uint256 remainingAmountWithdraw = stakeFrom.initial.sub(
-            (stakeFrom.withdrawn.add(stakeFrom.slashed))
-        );
-
-        if (withdrawalRequestsByIndex[msg.sender][scheduleIdx].amount > remainingAmountWithdraw) {
-            withdrawalRequestsByIndex[msg.sender][scheduleIdx].amount = remainingAmountWithdraw;
-        }
-
-        uint256 voteAmountWithdraw = remainingAmountWithdraw.sub(
-            withdrawalRequestsByIndex[msg.sender][scheduleIdx].amount
-        );
-        uint256 voteAmountDeposit = (stakeTo.initial.sub((stakeTo.withdrawn.add(stakeTo.slashed))))
-            .sub(withdrawalRequestsByIndex[msg.sender][0].amount);
-
-        depositWithdrawEvent(
-            msg.sender,
-            voteAmountWithdraw,
-            scheduleIdx,
-            msg.sender,
-            voteAmountDeposit,
-            0
-        );
-
-        emit ZeroSweep(msg.sender, amount, scheduleIdx);
-    }
-
     function availableForWithdrawal(address account, uint256 scheduleIndex)
         external
         view
@@ -279,237 +196,133 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         _depositFor(msg.sender, amount, scheduleIndex);
     }
 
-    function deposit(uint256 amount) external override {
-        _depositFor(msg.sender, amount, 0);
-    }
-
     function depositFor(
         address account,
         uint256 amount,
         uint256 scheduleIndex
-    ) external override onlyPermissionedDepositors {
+    ) external override {
+        require(_isAllowedPermissionedDeposit(), "PERMISSIONED_FUNCTION");
         _depositFor(account, amount, scheduleIndex);
     }
 
     function depositWithSchedule(
         address account,
         uint256 amount,
-        StakingSchedule calldata schedule,
-        address notional
+        StakingSchedule calldata schedule
     ) external override onlyPermissionedDepositors {
         uint256 scheduleIx = nextScheduleIndex;
-        _addSchedule(schedule, notional);
+        _addSchedule(schedule);
         _depositFor(account, amount, scheduleIx);
     }
 
-    function requestWithdrawal(uint256 amount, uint256 scheduleIdx) external override {
+    function requestWithdrawal(uint256 amount) external override {
         require(amount > 0, "INVALID_AMOUNT");
-        require(scheduleIdxs.contains(scheduleIdx), "INVALID_SCHEDULE");
-        uint256 availableAmount = _availableForWithdrawal(msg.sender, scheduleIdx);
-        require(availableAmount >= amount, "INSUFFICIENT_AVAILABLE");
+        StakingDetails[] memory stakes = _getStakes(msg.sender);
+        uint256 length = stakes.length;
+        uint256 stakedAvailable = 0;
+        for (uint256 i = 0; i < length; i++) {
+            stakedAvailable = stakedAvailable.add(
+                _availableForWithdrawal(msg.sender, stakes[i].scheduleIx)
+            );
+        }
 
-        withdrawalRequestsByIndex[msg.sender][scheduleIdx].amount = amount;
+        require(stakedAvailable >= amount, "INSUFFICIENT_AVAILABLE");
+
+        withheldLiquidity = withheldLiquidity.sub(requestedWithdrawals[msg.sender].amount).add(
+            amount
+        );
+        requestedWithdrawals[msg.sender].amount = amount;
         if (manager.getRolloverStatus()) {
-            withdrawalRequestsByIndex[msg.sender][scheduleIdx].minCycleIndex = manager
-                .getCurrentCycleIndex()
-                .add(2);
+            requestedWithdrawals[msg.sender].minCycleIndex = manager.getCurrentCycleIndex().add(2);
         } else {
-            withdrawalRequestsByIndex[msg.sender][scheduleIdx].minCycleIndex = manager
-                .getCurrentCycleIndex()
-                .add(1);
+            requestedWithdrawals[msg.sender].minCycleIndex = manager.getCurrentCycleIndex().add(1);
         }
 
-        bytes32 eventSig = "Withdrawal Request";
-        encodeAndSendData(eventSig, msg.sender, scheduleIdx, availableAmount.sub(amount));
+        bytes32 eventSig = "WithdrawalRequest";
+        encodeAndSendData(eventSig, msg.sender);
 
-        emit WithdrawalRequested(msg.sender, scheduleIdx, amount);
+        emit WithdrawalRequested(msg.sender, amount);
     }
 
-    function withdraw(uint256 amount, uint256 scheduleIdx)
-        external
-        override
-        nonReentrant
-        whenNotPaused
-    {
+    function withdraw(uint256 amount) external override nonReentrant whenNotPaused {
+        require(amount <= requestedWithdrawals[msg.sender].amount, "WITHDRAW_INSUFFICIENT_BALANCE");
         require(amount > 0, "NO_WITHDRAWAL");
-        require(scheduleIdxs.contains(scheduleIdx), "INVALID_SCHEDULE");
-        _withdraw(amount, scheduleIdx);
-    }
-
-    function withdraw(uint256 amount) external override whenNotPaused nonReentrant {
-        require(amount > 0, "INVALID_AMOUNT");
-        _withdraw(amount, 0);
-    }
-
-    function slash(
-        address[] calldata accounts,
-        uint256[] calldata amounts,
-        uint256 scheduleIndex
-    ) external override onlyOwner whenNotPaused {
-        require(accounts.length == amounts.length, "LENGTH_MISMATCH");
-        StakingSchedule storage schedule = schedules[scheduleIndex];
-        require(schedule.setup, "INVALID_SCHEDULE");
-
-        for (uint256 i = 0; i < accounts.length; i++) {
-            address account = accounts[i];
-            uint256 amount = amounts[i];
-
-            require(amount > 0, "INVALID_AMOUNT");
-            require(account != address(0), "INVALID_ADDRESS");
-
-            StakingDetails memory userStake = userStakings[account][scheduleIndex];
-            require(userStake.initial > 0, "NO_VESTING");
-
-            uint256 availableToSlash = 0;
-            uint256 remaining = userStake.initial.sub(userStake.withdrawn);
-            if (remaining > userStake.slashed) {
-                availableToSlash = remaining.sub(userStake.slashed);
-            }
-
-            require(availableToSlash >= amount, "INSUFFICIENT_AVAILABLE");
-
-            userStake.slashed = userStake.slashed.add(amount);
-            userStakings[account][scheduleIndex] = userStake;
-
-            uint256 totalLeft = userStake.initial.sub((userStake.slashed.add(userStake.withdrawn)));
+        require(
+            requestedWithdrawals[msg.sender].minCycleIndex <= manager.getCurrentCycleIndex(),
+            "INVALID_CYCLE"
+        );
 
-            if (withdrawalRequestsByIndex[account][scheduleIndex].amount > totalLeft) {
-                withdrawalRequestsByIndex[account][scheduleIndex].amount = totalLeft;
+        StakingDetails[] memory stakes = _getStakes(msg.sender);
+        uint256 available = 0;
+        uint256 length = stakes.length;
+        uint256 remainingAmount = amount;
+        uint256 stakedAvailable = 0;
+        for (uint256 i = 0; i < length && remainingAmount > 0; i++) {
+            stakedAvailable = _availableForWithdrawal(msg.sender, stakes[i].scheduleIx);
+            available = available.add(stakedAvailable);
+            if (stakedAvailable < remainingAmount) {
+                remainingAmount = remainingAmount.sub(stakedAvailable);
+                stakes[i].withdrawn = stakes[i].withdrawn.add(stakedAvailable);
+            } else {
+                stakes[i].withdrawn = stakes[i].withdrawn.add(remainingAmount);
+                remainingAmount = 0;
             }
-
-            uint256 voteAmount = totalLeft.sub(
-                withdrawalRequestsByIndex[account][scheduleIndex].amount
-            );
-            bytes32 eventSig = "Slashed";
-
-            encodeAndSendData(eventSig, account, scheduleIndex, voteAmount);
-
-            tokeToken.safeTransfer(treasury, amount);
-
-            emit Slashed(account, amount, scheduleIndex);
+            userStakings[msg.sender][stakes[i].scheduleIx] = stakes[i];
         }
-    }
 
-    function queueTransfer(
-        uint256 scheduleIdxFrom,
-        uint256 scheduleIdxTo,
-        uint256 amount,
-        address to
-    ) external override whenNotPaused {
-        _validateStakeTransfer(msg.sender, scheduleIdxFrom, scheduleIdxTo, amount, to);
-
-        require(queuedTransfers[msg.sender][scheduleIdxFrom].amount == 0, "TRANFER_QUEUED");
-
-        queuedTransfers[msg.sender][scheduleIdxFrom] = QueuedTransfer({
-            from: msg.sender,
-            scheduleIdxFrom: scheduleIdxFrom,
-            scheduleIdxTo: scheduleIdxTo,
-            amount: amount,
-            to: to
-        });
-
-        emit TransferQueued(msg.sender, scheduleIdxFrom, scheduleIdxTo, amount, to);
-    }
+        require(remainingAmount == 0, "INSUFFICIENT_AVAILABLE"); //May not need to check this again
 
-    function removeQueuedTransfer(uint256 scheduleIdxFrom) external override whenNotPaused {
-        QueuedTransfer memory queuedTransfer = queuedTransfers[msg.sender][scheduleIdxFrom];
-        delete queuedTransfers[msg.sender][scheduleIdxFrom];
-
-        emit QueuedTransferRemoved(
-            msg.sender,
-            queuedTransfer.scheduleIdxFrom,
-            queuedTransfer.scheduleIdxTo,
-            queuedTransfer.amount,
-            queuedTransfer.to
+        requestedWithdrawals[msg.sender].amount = requestedWithdrawals[msg.sender].amount.sub(
+            amount
         );
-    }
 
-    function rejectQueuedTransfer(address from, uint256 scheduleIdxFrom)
-        external
-        override
-        whenNotPaused
-    {
-        require(msg.sender == transferApprover, "NOT_APPROVER");
+        if (requestedWithdrawals[msg.sender].amount == 0) {
+            delete requestedWithdrawals[msg.sender];
+        }
 
-        QueuedTransfer memory queuedTransfer = queuedTransfers[from][scheduleIdxFrom];
-        require(queuedTransfer.amount != 0, "NO_TRANSFER_QUEUED");
+        bytes32 eventSig = "Withdraw";
+        encodeAndSendData(eventSig, msg.sender);
 
-        delete queuedTransfers[from][scheduleIdxFrom];
+        withheldLiquidity = withheldLiquidity.sub(amount);
+        tokeToken.safeTransfer(msg.sender, amount);
 
-        emit QueuedTransferRejected(
-            from,
-            scheduleIdxFrom,
-            queuedTransfer.scheduleIdxTo,
-            queuedTransfer.amount,
-            queuedTransfer.to
-        );
+        emit WithdrawCompleted(msg.sender, amount);
     }
 
-    function approveQueuedTransfer(
-        address from,
-        uint256 scheduleIdxFrom,
-        uint256 scheduleIdxTo,
+    function slash(
+        address account,
         uint256 amount,
-        address to
-    ) external override whenNotPaused nonReentrant {
-        QueuedTransfer memory queuedTransfer = queuedTransfers[from][scheduleIdxFrom];
-
-        require(msg.sender == transferApprover, "NOT_APPROVER");
-        require(queuedTransfer.scheduleIdxTo == scheduleIdxTo, "MISMATCH_SCHEDULE_TO");
-        require(queuedTransfer.amount == amount, "MISMATCH_AMOUNT");
-        require(queuedTransfer.to == to, "MISMATCH_TO");
-
-        delete queuedTransfers[from][scheduleIdxFrom];
-
-        _validateStakeTransfer(from, scheduleIdxFrom, scheduleIdxTo, amount, to);
+        uint256 scheduleIndex
+    ) external onlyOwner whenNotPaused {
+        StakingSchedule storage schedule = schedules[scheduleIndex];
+        require(amount > 0, "INVALID_AMOUNT");
+        require(schedule.setup, "INVALID_SCHEDULE");
 
-        WithdrawalInfo memory request = withdrawalRequestsByIndex[from][scheduleIdxFrom];
-        StakingDetails memory stake = userStakings[from][scheduleIdxFrom];
+        StakingDetails memory userStake = userStakings[account][scheduleIndex];
+        require(userStake.initial > 0, "NO_VESTING");
 
-        stake.initial = stake.initial.sub(amount);
-        userStakings[from][scheduleIdxFrom] = stake;
+        uint256 availableToSlash = 0;
+        uint256 remaining = userStake.initial.sub(userStake.withdrawn);
+        if (remaining > userStake.slashed) {
+            availableToSlash = remaining.sub(userStake.slashed);
+        }
 
-        StakingDetails memory newStake = _updateStakingDetails(scheduleIdxTo, to, amount);
-        request.amount = request.amount.sub(amount);
+        require(availableToSlash >= amount, "INSUFFICIENT_AVAILABLE");
 
-        if (request.amount == 0) {
-            delete withdrawalRequestsByIndex[from][scheduleIdxFrom];
-        } else {
-            withdrawalRequestsByIndex[from][scheduleIdxFrom] = request;
-        }
+        userStake.slashed = userStake.slashed.add(amount);
+        userStakings[account][scheduleIndex] = userStake;
 
-        uint256 voteAmountWithdraw = (stake.initial.sub((stake.withdrawn.add(stake.slashed)))).sub(
-            request.amount
-        );
-        uint256 voteAmountDeposit = (
-            newStake.initial.sub((newStake.withdrawn.add(newStake.slashed)))
-        ).sub(withdrawalRequestsByIndex[to][scheduleIdxTo].amount);
-        depositWithdrawEvent(
-            from,
-            voteAmountWithdraw,
-            scheduleIdxFrom,
-            to,
-            voteAmountDeposit,
-            scheduleIdxTo
-        );
+        bytes32 eventSig = "Slashed";
+        encodeAndSendData(eventSig, account);
 
-        emit StakeTransferred(from, scheduleIdxFrom, scheduleIdxTo, amount, to);
-    }
+        tokeToken.safeTransfer(treasury, amount);
 
-    function getQueuedTransfer(address fromAddress, uint256 fromScheduleId)
-        external
-        view
-        override
-        returns (QueuedTransfer memory)
-    {
-        return queuedTransfers[fromAddress][fromScheduleId];
+        emit Slashed(account, amount, scheduleIndex);
     }
 
     function setScheduleStatus(uint256 scheduleId, bool activeBool) external override onlyOwner {
         StakingSchedule storage schedule = schedules[scheduleId];
         schedule.isActive = activeBool;
-
-        emit ScheduleStatusSet(scheduleId, activeBool);
     }
 
     function pause() external override onlyOwner {
@@ -520,11 +333,7 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         _unpause();
     }
 
-    function setDestinations(address _fxStateSender, address _destinationOnL2)
-        external
-        override
-        onlyOwner
-    {
+    function setDestinations(address _fxStateSender, address _destinationOnL2) external override onlyOwner {
         require(_fxStateSender != address(0), "INVALID_ADDRESS");
         require(_destinationOnL2 != address(0), "INVALID_ADDRESS");
 
@@ -535,20 +344,11 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
     }
 
     function setEventSend(bool _eventSendSet) external override onlyOwner {
-        require(destinations.destinationOnL2 != address(0), "DESTINATIONS_NOT_SET");
-        
         _eventSend = _eventSendSet;
 
         emit EventSendSet(_eventSendSet);
     }
 
-    function setTransferApprover(address approver) external override onlyOwner {
-        require(approver != address(0), "INVALID_ADDRESS");
-        transferApprover = approver;
-
-        emit TransferApproverSet(approver);
-    }
-
     function _availableForWithdrawal(address account, uint256 scheduleIndex)
         private
         view
@@ -561,47 +361,6 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         return vestedWoWithdrawn.sub(stake.slashed);
     }
 
-    function _validateStakeTransfer(
-        address from,
-        uint256 scheduleIdxFrom,
-        uint256 scheduleIdxTo,
-        uint256 amount,
-        address to
-    ) private {
-        require(amount > 0, "INVALID_AMOUNT");
-        require(to != address(0), "INVALID_ADDRESS");
-        require(to != from, "CANNOT_BE_SELF");
-
-        WithdrawalInfo memory request = withdrawalRequestsByIndex[from][scheduleIdxFrom];
-        require(request.amount >= amount, "WITHDRAW_REQUEST_NOT_COVER");
-        require(manager.getCurrentCycleIndex() >= request.minCycleIndex, "INVALID_CYCLE");
-
-        StakingSchedule memory scheduleTo = schedules[scheduleIdxTo];
-
-        if (scheduleIdxFrom != scheduleIdxTo) {
-            require(scheduleTo.setup, "MUST_BE_SETUP");
-            require(scheduleTo.isActive, "MUST_BE_ACTIVE");
-
-            StakingSchedule memory scheduleFrom = schedules[scheduleIdxFrom];
-            require(
-                scheduleTo.hardStart.add(scheduleTo.cliff) >=
-                    scheduleFrom.hardStart.add(scheduleFrom.cliff),
-                "CLIFF_MUST_BE_LONGER"
-            );
-            require(
-                scheduleTo.hardStart.add(scheduleTo.cliff).add(scheduleTo.duration) >=
-                    scheduleFrom.hardStart.add(scheduleFrom.cliff).add(scheduleFrom.duration),
-                "SCHEDULE_MUST_BE_LONGER"
-            );
-        }
-
-        StakingDetails memory stake = userStakings[from][scheduleIdxFrom];
-        require(
-            amount <= stake.initial.sub((stake.withdrawn.add(stake.slashed))),
-            "INVALID_AMOUNT"
-        );
-    }
-
     function _depositFor(
         address account,
         uint256 amount,
@@ -614,38 +373,28 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         require(account != address(0), "INVALID_ADDRESS");
         require(schedule.isPublic || _isAllowedPermissionedDeposit(), "PERMISSIONED_SCHEDULE");
 
-        StakingDetails memory userStake = _updateStakingDetails(scheduleIndex, account, amount);
+        StakingDetails memory userStake = userStakings[account][scheduleIndex];
+        if (userStake.initial == 0) {
+            userStakingSchedules[account].push(scheduleIndex);
+        }
+        userStake.initial = userStake.initial.add(amount);
+        if (schedule.hardStart > 0) {
+            userStake.started = schedule.hardStart;
+        } else {
+            // solhint-disable-next-line not-rely-on-time
+            userStake.started = block.timestamp;
+        }
+        userStake.scheduleIx = scheduleIndex;
+        userStakings[account][scheduleIndex] = userStake;
 
         bytes32 eventSig = "Deposit";
-        uint256 voteTotal = userStake.initial.sub((userStake.slashed.add(userStake.withdrawn)));
-        encodeAndSendData(eventSig, account, scheduleIndex, voteTotal);
+        encodeAndSendData(eventSig, account);
 
         tokeToken.safeTransferFrom(msg.sender, address(this), amount);
 
         emit Deposited(account, amount, scheduleIndex);
     }
 
-    function _withdraw(uint256 amount, uint256 scheduleIdx) private {
-        WithdrawalInfo memory request = withdrawalRequestsByIndex[msg.sender][scheduleIdx];
-        require(amount <= request.amount, "INSUFFICIENT_AVAILABLE");
-        require(request.minCycleIndex <= manager.getCurrentCycleIndex(), "INVALID_CYCLE");
-
-        StakingDetails memory userStake = userStakings[msg.sender][scheduleIdx];
-        userStake.withdrawn = userStake.withdrawn.add(amount);
-        userStakings[msg.sender][scheduleIdx] = userStake;
-
-        request.amount = request.amount.sub(amount);
-        withdrawalRequestsByIndex[msg.sender][scheduleIdx] = request;
-
-        if (request.amount == 0) {
-            delete withdrawalRequestsByIndex[msg.sender][scheduleIdx];
-        }
-
-        tokeToken.safeTransfer(msg.sender, amount);
-
-        emit WithdrawCompleted(msg.sender, scheduleIdx, amount);
-    }
-
     function _vested(address account, uint256 scheduleIndex) private view returns (uint256) {
         // solhint-disable-next-line not-rely-on-time
         uint256 timestamp = block.timestamp;
@@ -659,8 +408,7 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
                 value = stake.initial;
             } else {
                 uint256 secondsStaked = Math.max(timestamp.sub(cliffTimestamp), 1);
-                //Precision loss is intentional. Enables the interval buckets
-                uint256 effectiveSecondsStaked = (secondsStaked.div(schedule.interval)).mul(
+                uint256 effectiveSecondsStaked = (secondsStaked.mul(schedule.interval)).div(
                     schedule.interval
                 );
                 value = stake.initial.mul(effectiveSecondsStaked).div(schedule.duration);
@@ -670,16 +418,14 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         return value;
     }
 
-    function _addSchedule(StakingSchedule memory schedule, address notional) private {
+    function _addSchedule(StakingSchedule memory schedule) private {
         require(schedule.duration > 0, "INVALID_DURATION");
         require(schedule.interval > 0, "INVALID_INTERVAL");
-        require(notional != address(0), "INVALID_ADDRESS");
 
         schedule.setup = true;
         uint256 index = nextScheduleIndex;
         schedules[index] = schedule;
-        notionalAddresses[index] = notional;
-        require(scheduleIdxs.add(index), "ADD_FAIL");
+        scheduleIdxs.add(index);
         nextScheduleIndex = nextScheduleIndex.add(1);
 
         emit ScheduleAdded(
@@ -689,8 +435,7 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
             schedule.interval,
             schedule.setup,
             schedule.isActive,
-            schedule.hardStart,
-            notional
+            schedule.hardStart
         );
     }
 
@@ -707,62 +452,19 @@ contract Staking is IStaking, Initializable, Ownable, Pausable, ReentrancyGuard,
         return permissionedDepositors[msg.sender] || msg.sender == owner();
     }
 
-    function encodeAndSendData(
-        bytes32 _eventSig,
-        address _user,
-        uint256 _scheduleIdx,
-        uint256 _userBalance
-    ) private onEventSend {
+    function encodeAndSendData(bytes32 _eventSig, address _user) private onEventSend {
         require(address(destinations.fxStateSender) != address(0), "ADDRESS_NOT_SET");
         require(destinations.destinationOnL2 != address(0), "ADDRESS_NOT_SET");
-        address notionalAddress = notionalAddresses[_scheduleIdx];
-
-        bytes memory data = abi.encode(
-            BalanceUpdateEvent({
-                eventSig: _eventSig,
-                account: _user,
-                token: notionalAddress,
-                amount: _userBalance
-            })
-        );
 
-        destinations.fxStateSender.sendMessageToChild(destinations.destinationOnL2, data);
-    }
+        uint256 userBalance = balanceOf(_user).sub(requestedWithdrawals[_user].amount);
+        bytes memory data = abi.encode(BalanceUpdateEvent({
+            eventSig: _eventSig,
+            account: _user, 
+            token: address(tokeToken), 
+            amount: userBalance
+        }));
 
-    function _updateStakingDetails(
-        uint256 scheduleIdx,
-        address account,
-        uint256 amount
-    ) private returns (StakingDetails memory) {
-        StakingDetails memory stake = userStakings[account][scheduleIdx];
-        if (stake.started == 0) {
-            userStakingSchedules[account].push(scheduleIdx);
-            StakingSchedule memory schedule = schedules[scheduleIdx];
-            if (schedule.hardStart > 0) {
-                stake.started = schedule.hardStart;
-            } else {
-                //solhint-disable-next-line not-rely-on-time
-                stake.started = block.timestamp;
-            }
-        }
-        stake.initial = stake.initial.add(amount);
-        stake.scheduleIx = scheduleIdx;
-        userStakings[account][scheduleIdx] = stake;
-
-        return stake;
-    }
-
-    function depositWithdrawEvent(
-        address withdrawUser,
-        uint256 withdrawAmount,
-        uint256 withdrawScheduleIdx,
-        address depositUser,
-        uint256 depositAmount,
-        uint256 depositScheduleIdx
-    ) private {
-        bytes32 withdrawEvent = "Withdraw";
-        bytes32 depositEvent = "Deposit";
-        encodeAndSendData(withdrawEvent, withdrawUser, withdrawScheduleIdx, withdrawAmount);
-        encodeAndSendData(depositEvent, depositUser, depositScheduleIdx, depositAmount);
+        destinations.fxStateSender.sendMessageToChild(destinations.destinationOnL2, data);
     }
 }
+