@@ -18,15 +18,17 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
     address token0;
     address token1;
 
-    uint256 threshold = 500000; //50%
+    uint256 threshold = 400000; //40%
     uint256 delay = 120 minutes; //10 minutes
 
-    uint160 initialPoolPrice = 25054144837504793118641380156;
+    uint160 initialPoolPrice;
 
     PoolUser u1;
     PoolUser u2;
     PoolUser u3;
-    PoolUser u4_whale;
+    PoolUser u4;
+
+    PoolUser[4] public users;
 
     function setUp() public {
         // Deploy GEB
@@ -38,29 +40,28 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         testWeth = new TestWETH("WETH");
         (token0, token1) = address(testRai) < address(testWeth) ? (address(testRai), address(testWeth)) : (address(testWeth), address(testRai));
 
-        emit log_named_address("testRai", address(testRai));
-        emit log_named_address("testWeth", address(testWeth));
-        emit log_named_address("token0", address(token0));
-        emit log_named_address("token1", address(token1));
-
         // Deploy Pool
         pool = UniswapV3Pool(helper_deployV3Pool(token0, token1, 500));
 
         // We have to give an inital price to the wethUsd // This meas 10:1(10 RAI for 1 ETH).
         // This number is the sqrt of the price = sqrt(0.1) multiplied by 2 ** 96
-        pool.initialize(uint160(initialPoolPrice));
         manager = new GebUniswapV3LiquidityManager("Geb-Uniswap-Manager", "GUM", address(testRai), threshold, delay, address(pool), bytes32("ETH"), oracle);
 
-        u1 = new PoolUser(manager);
-        u2 = new PoolUser(manager);
-        u3 = new PoolUser(manager);
-        u4_whale = new PoolUser(manager);
+        //Will initialize the pool with current price
+        initialPoolPrice = helper_getRebalancePrice();
+        pool.initialize(initialPoolPrice);
+
+        u1 = new PoolUser(manager, pool, testRai, testWeth);
+        u2 = new PoolUser(manager, pool, testRai, testWeth);
+        u3 = new PoolUser(manager, pool, testRai, testWeth);
+        u4 = new PoolUser(manager, pool, testRai, testWeth);
+
+        users[0] = u1;
+        users[1] = u2;
+        users[2] = u3;
+        users[3] = u4;
 
-        address[] memory adds = new address[](3);
-        adds[0] = address(u1);
-        adds[1] = address(u2);
-        adds[2] = address(u3);
-        helper_transferToAdds(adds);
+        helper_transferToAdds(users);
 
         // Make the pool start with some spread out liquidity
         helper_addWhaleLiquidity();
@@ -94,11 +95,25 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         oracle.setSystemCoinPrice(newPrice);
     }
 
-    function helper_transferToAdds(address[] memory adds) public {
+    function helper_transferToAdds(PoolUser[4] memory adds) public {
         for (uint256 i = 0; i < adds.length; i++) {
-            testWeth.transfer(adds[i], 100 ether);
-            testRai.transfer(adds[i], 100 ether);
+            testWeth.transfer(address(adds[i]), 100 ether);
+            testRai.transfer(address(adds[i]), 100 ether);
+        }
+    }
+
+    function helper_getRebalancePrice() public returns (uint160) {
+        // 1. Get prices from the oracle relayer
+        (uint256 redemptionPrice, uint256 ethUsdPrice) = manager.getPrices();
+
+        // 2. Calculate the price ratio
+        uint160 sqrtPriceX96;
+        if (!(address(pool.token0()) == address(testRai))) {
+            sqrtPriceX96 = uint160(sqrt((redemptionPrice << 96) / ethUsdPrice));
+        } else {
+            sqrtPriceX96 = uint160(sqrt((ethUsdPrice << 96) / redemptionPrice));
         }
+        return sqrtPriceX96;
     }
 
     function helper_addWhaleLiquidity() public {
@@ -108,22 +123,38 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
         uint128 liq = helper_getLiquidityAmountsForTicks(sqrtRatioX96, -887270, 887270, wethAmount, raiAmount);
 
-        pool.mint(address(u4_whale), -887270, 887270, liq, bytes(""));
+        int24 low = -887270;
+        int24 upp = 887270;
+        pool.mint(address(this), low, upp, liq, bytes(""));
+        // bytes32 id = keccak256(abi.encodePacked(address(this), low, upp));
+        // (uint128 _liquidity, , , , ) = pool.positions(id);
+
+        // (uint256 am0, uint256 am1) = pool.burn(low, upp, liq);
+        // emit log_named_uint("am0", am0);
+        // emit log_named_uint("am1", am1);
     }
 
-    function helper_addLiquidity() public {
+    function helper_addLiquidity(uint8 user) public {
+        (bytes32 i_id, , , uint128 i_uniLiquidity) = manager.position();
+        (uint128 i_liquidity, , , , ) = pool.positions(i_id);
+        PoolUser u = users[(user - 1) % 4];
         uint256 wethAmount = 1 ether;
         uint256 raiAmount = 10 ether;
 
-        u1.doApprove(address(testRai), address(manager), raiAmount);
-        u1.doApprove(address(testWeth), address(manager), wethAmount);
+        u.doApprove(address(testRai), address(manager), raiAmount);
+        u.doApprove(address(testWeth), address(manager), wethAmount);
 
-        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
-        uint128 liq = helper_getLiquidityAmountsForTicks(sqrtRatioX96, -887270, 887270, wethAmount, raiAmount);
+        (int24 newLower, int24 newUpper) = manager.getNextTicks();
 
-        //Adding liquidty without changing current price. To use the full amount of tokens we would need to add sqrt(10)
-        //But we'll add an approximation
-        u1.doDeposit(liq);
+        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
+        uint128 liq = helper_getLiquidityAmountsForTicks(sqrtRatioX96, newLower, newUpper, wethAmount, raiAmount);
+        u.doDeposit(liq);
+        // (bytes32 e_id, , , uint128 e_uniLiquidity) = manager.position();
+        // (uint128 e_liquidity, , , , ) = pool.positions(e_id);
+        // emit log_named_uint("i_uniLiquidity", i_uniLiquidity);
+        // emit log_named_uint("i_liquidity", i_liquidity);
+        // emit log_named_uint("e_uniLiquidity", e_uniLiquidity);
+        // emit log_named_uint("e_liquidity", e_liquidity);
     }
 
     function helper_getLiquidityAmountsForTicks(
@@ -150,6 +181,26 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         }
     }
 
+    function helper_do_swap() public {
+        (uint160 currentPrice, , , , , , ) = pool.slot0();
+        uint160 sqrtLimitPrice = currentPrice - 100000000000000;
+        pool.swap(address(this), true, 10 ether, sqrtLimitPrice, bytes(""));
+    }
+
+    function helper_get_random_zeroForOne_priceLimit(int256 _amountSpecified) internal view returns (uint160 sqrtPriceLimitX96) {
+        // help echidna a bit by calculating a valid sqrtPriceLimitX96 using the amount as random seed
+        (uint160 currentPrice, , , , , , ) = pool.slot0();
+        uint160 minimumPrice = TickMath.MIN_SQRT_RATIO;
+        sqrtPriceLimitX96 = minimumPrice + uint160((uint256(_amountSpecified > 0 ? _amountSpecified : -_amountSpecified) % (currentPrice - minimumPrice)));
+    }
+
+    function helper_get_random_oneForZero_priceLimit(int256 _amountSpecified) internal view returns (uint160 sqrtPriceLimitX96) {
+        // help echidna a bit by calculating a valid sqrtPriceLimitX96 using the amount as random seed
+        (uint160 currentPrice, , , , , , ) = pool.slot0();
+        uint160 maximumPrice = TickMath.MAX_SQRT_RATIO;
+        sqrtPriceLimitX96 = currentPrice + uint160((uint256(_amountSpecified > 0 ? _amountSpecified : -_amountSpecified) % (maximumPrice - currentPrice)));
+    }
+
     function uniswapV3MintCallback(
         uint256 amount0Owed,
         uint256 amount1Owed,
@@ -159,6 +210,20 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         testWeth.transfer(msg.sender, amount0Owed);
     }
 
+    function uniswapV3SwapCallback(
+        int256 amount0Delta,
+        int256 amount1Delta,
+        bytes calldata data
+    ) external {
+        if (address(pool.token0()) == address(testRai)) {
+            if (amount0Delta > 0) testRai.transfer(msg.sender, uint256(amount0Delta));
+            if (amount1Delta > 0) testWeth.transfer(msg.sender, uint256(amount1Delta));
+        } else {
+            if (amount1Delta > 0) testRai.transfer(msg.sender, uint256(amount1Delta));
+            if (amount0Delta > 0) testWeth.transfer(msg.sender, uint256(amount0Delta));
+        }
+    }
+
     function test_sanity_uint_variables() public {
         uint256 _delay = manager.delay();
         assertTrue(_delay == delay);
@@ -210,6 +275,16 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         assertTrue(address(manager.oracle()) == newOracle);
     }
 
+    function testFail_thirdyParty_changingParameter() public {
+        bytes memory data = abi.encodeWithSignature("modifyParameters(bytes32,uint256)", bytes32("threshold"), 20000);
+        u1.doArbitrary(address(manager), data);
+    }
+
+    function testFail_thirdyParty_changingOracle() public {
+        bytes memory data = abi.encodeWithSignature("modifyParameters(bytes32,address)", bytes32("oracle"), address(4));
+        u1.doArbitrary(address(manager), data);
+    }
+
     function test_adding_liquidity() public {
         uint256 wethAmount = 1 ether;
         uint256 raiAmount = 10 ether;
@@ -251,20 +326,46 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
     }
 
     function test_rebalancing_pool() public {
-        helper_addLiquidity(); //Starting with a bit of liquidity
-        (uint256 red, ) = manager.getPrices();
+        helper_addLiquidity(1); //Starting with a bit of liquidity
+        helper_addLiquidity(2); //Starting with a bit of liquidity
+        helper_addLiquidity(3); //Starting with a bit of liquidity
+
+        testRai.approve(address(manager), 10);
+        testWeth.approve(address(manager), 10);
 
         (bytes32 init_id, int24 init_lowerTick, int24 init_upperTick, uint128 init_uniLiquidity) = manager.position();
-        emit log_named_uint("red", red);
+        if (init_lowerTick > 0) {
+            emit log_named_uint("pos init_lowerTick", helper_getAbsInt24(init_lowerTick));
+        } else {
+            emit log_named_uint("neg init_lowerTick", helper_getAbsInt24(init_lowerTick));
+        }
+
+        if (init_upperTick > 0) {
+            emit log_named_uint("pos init_upperTick", helper_getAbsInt24(init_upperTick));
+        } else {
+            emit log_named_uint("neg init_upperTick", helper_getAbsInt24(init_upperTick));
+        }
         hevm.warp(2 days); //Advance to the future
 
-        helper_changeRedemptionPrice(500000000 ether); //Making RAI twice more expensive
+        helper_changeRedemptionPrice(1000000000 ether); //Making RAI a bit more expensive
 
         (int24 newLower, int24 newUpper) = manager.getNextTicks();
+        if (newLower > 0) {
+            emit log_named_uint("pos newLower", helper_getAbsInt24(newLower));
+        } else {
+            emit log_named_uint("neg newLower", helper_getAbsInt24(newLower));
+        }
+
+        if (newUpper > 0) {
+            emit log_named_uint("pos newUpper", helper_getAbsInt24(newUpper));
+        } else {
+            emit log_named_uint("neg newUpper", helper_getAbsInt24(newUpper));
+        }
 
         // The lower bound might still be the same, since is current the MIN_TICK
         assertTrue(init_upperTick != newUpper);
 
+        emit log_named_uint("red", 222);
         manager.rebalance();
         // emit log_named_uint("am0", collected0);
         // emit log_named_uint("am1", collected1);
@@ -275,18 +376,27 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         (bytes32 end_id, int24 end_lowerTick, int24 end_upperTick, uint128 end_uniLiquidity) = manager.position();
 
         assertTrue(end_uniLiquidity <= init_uniLiquidity);
+        // assertTrue(false);
+    }
+
+    function testFail_early_rebalancing() public {
+        hevm.warp(2 days); //Advance to the future
+        manager.rebalance(); // should pass
+        hevm.warp(2 minutes); //Advance to the future
+        manager.rebalance(); // should fail
     }
 
     function test_burning_liquidity() public {
         uint256 wethAmount = 1 ether;
         uint256 raiAmount = 10 ether;
-        helper_addLiquidity(); //Starting with a bit of liquidity
+        helper_addLiquidity(1); //Starting with a bit of liquidity
 
         uint256 liq = manager.balanceOf(address(u1));
         (bytes32 inti_id, , , uint128 inti_uniLiquidity) = manager.position();
         (uint128 _li, , , , ) = pool.positions(inti_id);
 
         assertTrue(liq == _li);
+        emit log_named_uint("liq", liq);
         emit log_named_uint("liq", inti_uniLiquidity);
         emit log_named_uint("_li", _li);
 
@@ -305,6 +415,110 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         assertTrue(end_uniLiquidity - 1 == inti_uniLiquidity / 2);
     }
 
+    function test_collecting_fees() public {
+        (uint256 redemptionPrice, uint256 ethUsdPrice) = manager.getPrices();
+        emit log_named_uint("redemptionPrice", redemptionPrice);
+        emit log_named_uint("ethUsdPrice", ethUsdPrice);
+        //          redemptionPrice: 1000000000000000000000000000
+        //   ethUsdPrice: 300000000000000000000
+
+        (uint160 price0, int24 tick0, , , , , ) = pool.slot0();
+        emit log_named_uint("price1", price0);
+        if (tick0 > 0) {
+            emit log_named_uint("pos tick0", helper_getAbsInt24(tick0));
+        } else {
+            emit log_named_uint("neg tick0", helper_getAbsInt24(tick0));
+        }
+
+        uint256 wethAmount = 1 ether;
+        uint256 raiAmount = 10 ether;
+
+        u2.doApprove(address(testRai), address(manager), raiAmount);
+        u2.doApprove(address(testWeth), address(manager), wethAmount);
+
+        (uint160 price1, , , , , , ) = pool.slot0();
+        (int24 newLower, int24 newUpper) = manager.getNextTicks();
+
+        uint128 liq = helper_getLiquidityAmountsForTicks(price1, newLower, newUpper, 1 ether, 10 ether);
+
+        uint256 bal0w = testWeth.balanceOf(address(u2));
+        uint256 bal0r = testRai.balanceOf(address(u2));
+        u2.doDeposit(liq);
+
+        helper_do_swap();
+
+        u2.doWithdraw(liq);
+
+        uint256 bal1w = testWeth.balanceOf(address(u2));
+        uint256 bal1r = testRai.balanceOf(address(u2));
+        emit log_named_uint("bal0w", bal0w);
+        emit log_named_uint("bal0r", bal0r);
+        emit log_named_uint("bal1w", bal1w);
+        emit log_named_uint("bal1r", bal1r);
+        // Pretty hard to test this,tbh
+        (uint160 price2, , , , , , ) = pool.slot0();
+
+        emit log_named_uint("price1", price1);
+        emit log_named_uint("price2", price2);
+
+        (bytes32 id, , , ) = manager.position();
+        (uint128 _liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(id);
+
+        emit log_named_uint("_liquidity", _liquidity);
+        emit log_named_uint("feeGrowthInside0LastX128", feeGrowthInside0LastX128);
+        emit log_named_uint("feeGrowthInside1LastX128", feeGrowthInside1LastX128);
+        emit log_named_uint("tokensOwed0", tokensOwed0);
+        emit log_named_uint("tokensOwed1", tokensOwed1);
+
+        assertTrue(bal1w > bal0w);
+    }
+
+    function test_multiple_users_depositing() public {
+        helper_addLiquidity(1); //Starting with a bit of liquidity
+        uint256 u1_balance = manager.balanceOf(address(u1));
+        assert(u1_balance == manager.totalSupply());
+
+        helper_addLiquidity(2); //Starting with a bit of liquidity
+        uint256 u2_balance = manager.balanceOf(address(u2));
+        assert(u1_balance + u2_balance == manager.totalSupply());
+
+        helper_addLiquidity(3); //Starting with a bit of liquidity
+        uint256 u3_balance = manager.balanceOf(address(u3));
+        assert(u1_balance + u2_balance + u3_balance == manager.totalSupply());
+    }
+
+    function test_mint_transfer_and_burn() public {
+        helper_addLiquidity(1); //Starting with a bit of liquidity
+        u1.doTransfer(address(manager), address(u3), manager.balanceOf(address(u1)));
+        u3.doWithdraw(uint128(manager.balanceOf(address(u3))));
+    }
+
+    function test_liquidty_proportional_to_balance() public {
+        testRai.approve(address(manager), 10);
+        testWeth.approve(address(manager), 10);
+        helper_addLiquidity(1);
+
+        //Make Rai twice more Expensive
+        helper_changeRedemptionPrice(2000000000 ether);
+
+        //Add a send liquidity
+        helper_addLiquidity(1);
+
+        //Return to it's otiginal price
+        helper_changeRedemptionPrice(1200000000 ether);
+        hevm.warp(2 days);
+
+        manager.rebalance();
+
+        (bytes32 id, , , uint128 uniLiquidity1) = manager.position();
+        (uint128 _liquidity, , , , ) = pool.positions(id);
+        emit log_named_uint("_liquidity", _liquidity);
+        emit log_named_uint("liq", uniLiquidity1);
+        emit log_named_uint("bal", manager.balanceOf(address(u1)));
+        //user should be able to withdraw it's whole balance. Balance != Liquidity
+        u1.doWithdraw(uint128(manager.balanceOf(address(u1))));
+    }
+
     function test_multiple_users_adding_liquidity() public {
         uint256 u1_raiAmount = 5 ether;
         uint256 u1_wethAmount = 2 ether;
@@ -358,6 +572,40 @@ contract GebUniswapv3LiquidityManagerTest is DSTest {
         (uint256 redemptionPrice, uint256 ethUsdPrice) = manager.getPrices();
 
         uint160 sqrtRedPriceX96 = uint160(sqrt((ethUsdPrice * 2**96) / redemptionPrice));
-        assertTrue(sqrtRedPriceX96 == 154170194117); //Value taken from uniswap sdk
+        assertTrue(sqrtRedPriceX96 == 140737488355); //Value taken from uniswap sdk
+    }
+
+    function testFail_try_minting_zero_liquidity() public {
+        uint256 wethAmount = 1 ether;
+        uint256 raiAmount = 10 ether;
+
+        u1.doApprove(address(testRai), address(manager), raiAmount);
+        u1.doApprove(address(testWeth), address(manager), wethAmount);
+
+        emit log_named_uint("depositing", 0);
+        u1.doDeposit(0);
+    }
+
+    function testFail_minting_largest_liquidity() public {
+        uint256 wethAmount = 1 ether;
+        uint256 raiAmount = 10 ether;
+
+        u1.doApprove(address(testRai), address(manager), raiAmount);
+        u1.doApprove(address(testWeth), address(manager), wethAmount);
+
+        emit log_named_uint("depositing", 0);
+        u1.doDeposit(uint128(0 - 1));
+    }
+
+    function testFail_burning_zero_liquidity() public {
+        helper_addLiquidity(3);
+
+        u3.doWithdraw(0);
+    }
+
+    function testFail_burning_more_than_owned_liquidity() public {
+        helper_addLiquidity(3);
+
+        u3.doWithdraw(uint128(0 - 1));
     }
 }