@@ -156,12 +156,21 @@ contract HermesImplementation is FundsRecovery, Utils {
     function openChannel(address _identity, uint256 _amountToStake) public {
         require(msg.sender == address(registry), "Hermes: only registry can open channels");
         require(getStatus() == Status.Active, "Hermes: have to be in active state");
+        require(_amountToStake >= minStake, "Hermes: min stake amount not reached");
         _increaseStake(getChannelId(_identity), _amountToStake, false);
     }
 
     // Settle promise
     // _preimage is random number generated by receiver used in HTLC
-    function _settlePromise(bytes32 _channelId, address _identity, address _beneficiary, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature, bool _takeFee) private returns (uint256) {
+    function _settlePromise(
+        bytes32 _channelId,
+        uint256 _amount,
+        uint256 _transactorFee,
+        bytes32 _preimage,
+        bytes memory _signature,
+        bool _takeFee,
+        bool _ignoreStake
+    ) private returns (uint256, uint256) {
         require(
             isHermesActive(),
             "Hermes: hermes have to be in active state"
@@ -172,6 +181,7 @@ contract HermesImplementation is FundsRecovery, Utils {
         );
 
         Channel storage _channel = channels[_channelId];
+        require(_channel.settled > 0 || _channel.stake >= minStake || _ignoreStake, "Hermes: not enough stake");
 
         // If there are not enought funds to rebalance we have to enable punishment mode.
         uint256 _availableBalance = availableBalance();
@@ -201,9 +211,7 @@ contract HermesImplementation is FundsRecovery, Utils {
 
         uint256 _amountToTransfer = _unpaidAmount -_fees;
 
-        emit PromiseSettled(_identity, _channelId, _beneficiary, _amountToTransfer, _fees, _preimage);
-
-        return _amountToTransfer;
+        return (_amountToTransfer, _fees);
     }
 
     function settlePromise(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature) public {
@@ -212,8 +220,10 @@ contract HermesImplementation is FundsRecovery, Utils {
 
         // Settle promise and transfer calculated amount into beneficiary wallet
         bytes32 _channelId = getChannelId(_identity);
-        uint256 _amountToTransfer = _settlePromise(_channelId, _identity, _beneficiary, _amount, _transactorFee, _preimage, _signature, true);
+        (uint256 _amountToTransfer, uint256 _fees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _signature, true, false);
         token.transfer(_beneficiary, _amountToTransfer);
+
+        emit PromiseSettled(_identity, _channelId, _beneficiary, _amountToTransfer, _fees, _preimage);
     }
 
     function payAndSettle(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature, address _beneficiary, bytes memory _beneficiarySignature) public {
@@ -223,8 +233,10 @@ contract HermesImplementation is FundsRecovery, Utils {
         address _signer = keccak256(abi.encodePacked(getChainID(), _channelId, _amount, _preimage, _beneficiary)).recover(_beneficiarySignature);
         require(_signer == _identity, "Hermes: payAndSettle request should be properly signed");
 
-        uint256 _amountToTransfer = _settlePromise(_channelId, _identity, _beneficiary, _amount, _transactorFee, _preimage, _signature, false);
+        (uint256 _amountToTransfer, uint256 _fees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _signature, false, true);
         token.transfer(_beneficiary, _amountToTransfer);
+
+        emit PromiseSettled(_identity, _channelId, _beneficiary, _amountToTransfer, _fees, _preimage);
     }
 
     function settleWithBeneficiary(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _promiseSignature, address _newBeneficiary, bytes memory _beneficiarySignature) public {
@@ -233,8 +245,10 @@ contract HermesImplementation is FundsRecovery, Utils {
 
         // Settle promise and transfer calculated amount into beneficiary wallet
         bytes32 _channelId = getChannelId(_identity);
-        uint256 _amountToTransfer = _settlePromise(_channelId, _identity, _newBeneficiary, _amount, _transactorFee, _preimage, _promiseSignature, true);
+        (uint256 _amountToTransfer, uint256 _fees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _promiseSignature, true, false);
         token.transfer(_newBeneficiary, _amountToTransfer);
+
+        emit PromiseSettled(_identity, _channelId, _newBeneficiary, _amountToTransfer, _fees, _preimage);
     }
 
     function settleWithDEX(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature) public {
@@ -243,7 +257,7 @@ contract HermesImplementation is FundsRecovery, Utils {
 
         // Calculate amount to transfer and settle promise
         bytes32 _channelId = getChannelId(_identity);
-        uint256 _amountToTransfer = _settlePromise(_channelId, _identity, _beneficiary, _amount, _transactorFee, _preimage, _signature, true);
+        (uint256 _amountToTransfer, uint256 _fees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _signature, true, false);
 
         // Transfer funds into beneficiary wallet via DEX
         uint amountOutMin = 0;
@@ -252,18 +266,19 @@ contract HermesImplementation is FundsRecovery, Utils {
         path[1] = dex.WETH();
 
         dex.swapExactTokensForETH(_amountToTransfer, amountOutMin, path, _beneficiary, block.timestamp);
+
+        emit PromiseSettled(_identity, _channelId, _beneficiary, _amountToTransfer, _fees, _preimage);
     }
 
     /*
       -------------------------------------- STAKE MANAGEMENT --------------------------------------
     */
 
     function _increaseStake(bytes32 _channelId, uint256 _amountToAdd, bool _duringSettlement) internal {
-        require(_amountToAdd > 0, "Hermes: should stake more than zero");
-
         Channel storage _channel = channels[_channelId];
         uint256 _newStakeAmount = _channel.stake +_amountToAdd;
         require(_newStakeAmount <= maxStake, "Hermes: total amount to stake can't be bigger than maximally allowed");
+        require(_newStakeAmount >= minStake, "Hermes: stake can't be less than required min stake");
 
         // We don't transfer tokens during settlements, they already locked in hermes contract.
         if (!_duringSettlement) {
@@ -285,7 +300,8 @@ contract HermesImplementation is FundsRecovery, Utils {
     // Settlement which will increase channel stake instead of transfering funds into beneficiary wallet.
     function settleIntoStake(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature) public {
         bytes32 _channelId = getChannelId(_identity);
-        uint256 _stakeIncreaseAmount = _settlePromise(_channelId, _identity, address(this), _amount, _transactorFee, _preimage, _signature, true);
+        (uint256 _stakeIncreaseAmount, uint256 _paidFees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _signature, true, true);
+        emit PromiseSettled(_identity, _channelId, address(this), _stakeIncreaseAmount, _paidFees, _preimage);
         _increaseStake(_channelId, _stakeIncreaseAmount, true);
     }
 
@@ -304,6 +320,7 @@ contract HermesImplementation is FundsRecovery, Utils {
         require(getChannelId(_signer) == _channelId, "Hermes: have to be signed by channel party");
 
         uint256 _newStakeAmount = _channel.stake - _amount;
+        require(_newStakeAmount == 0 || _newStakeAmount >= minStake, "Hermes: stake can't be less than required min stake");
 
         // Update channel state
         _channel.stake = _newStakeAmount;