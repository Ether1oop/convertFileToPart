@@ -112,6 +112,23 @@ contract Ownable {
     }
 }
 
+contract ReentrancyGuard {
+    /// @dev counter to allow mutex lock with only one SSTORE operation
+    uint256 private _guardCounter;
+
+    constructor () {
+        // The counter starts at one to prevent changing it from zero to a non-zero
+        // value, which is a more expensive operation.
+        _guardCounter = 1;
+    }
+
+    modifier nonReentrant() {
+        _guardCounter += 1;
+        uint256 localCounter = _guardCounter;
+        _;
+        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");
+    }
+}
 
 library Address {
     function isContract(address account) internal view returns (bool) {
@@ -333,7 +350,7 @@ interface ILending {
     function burnToBnb(address receiver, uint256 burnAmount) external returns (uint256 loanAmountPaid);
 }
 
-contract TikTokenStorage is Ownable, Context, ERC165 {    
+contract SmartLPStorage is Ownable, Context, ERC165, ReentrancyGuard {    
     IWBNB public WBNB;
     IRouter public swapRouter;
     ILpStaking public lpStakingBnbNbu;
@@ -351,6 +368,8 @@ contract TikTokenStorage is Ownable, Context, ERC165 {
       uint NbuBnbLpAmount;
       uint GnbuBnbLpAmount;
       uint LendedBNBAmount;
+      uint PoolNbuAmount;
+      uint PoolGnbuAmount;
       uint LendedITokenAmount;
       uint NbuBnbStakeNonce;
       uint GnbuBnbStakeNonce;
@@ -373,9 +392,9 @@ contract TikTokenStorage is Ownable, Context, ERC165 {
     mapping(address => mapping(address => bool)) internal _operatorApprovals;
     mapping(address => uint[]) internal _userTokens;
      
-    event BuyTikToken(address indexed user, uint indexed tokenId, uint providedBnb, uint supplyTime);
+    event BuySmartLP(address indexed user, uint indexed tokenId, uint providedBnb, uint supplyTime);
     event WithdrawRewards(address indexed user, uint indexed tokenId, uint lpNbuBnbUserRewards, uint lpGnbuBnbUserRewards);
-    event BurnTikToken(uint indexed tokenId);
+    event BurnSmartLP(uint indexed tokenId);
     event UpdateSwapRouter(address indexed newSwapRouterContract);
     event UpdateLpStakingBnbNbu(address indexed newLpStakingAContract);
     event UpdateLpStakingBnbGnbu(address indexed newLpStakingBContract);
@@ -385,12 +404,12 @@ contract TikTokenStorage is Ownable, Context, ERC165 {
     event UpdateMinPurchaseAmount(uint indexed newAmount);
 }
 
-contract TikTokenProxy is TikTokenStorage {
+contract SmartLPProxy is SmartLPStorage {
     address public target;
     
     event SetTarget(address indexed newTarget);
 
-    constructor(address _newTarget) TikTokenStorage() {
+    constructor(address _newTarget) SmartLPStorage() {
         _setTarget(_newTarget);
     }
 
@@ -423,7 +442,7 @@ contract TikTokenProxy is TikTokenStorage {
     }
 }
 
-contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
+contract SmartLP is SmartLPStorage, IBEP721, IBEP721Metadata {
     using Address for address;
     using Strings for uint256;
     
@@ -440,18 +459,18 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
         address _lpStakingBnbGnbu, 
         address _lendingContract
     ) external onlyOwner {
-        require(Address.isContract(_swapRouter), "NimbusTikToken_V1: Not contract");
-        require(Address.isContract(_wbnb), "NimbusTikToken_V1: Not contract");
-        require(Address.isContract(_nbuToken), "NimbusTikToken_V1: Not contract");
-        require(Address.isContract(_gnbuToken), "NimbusTikToken_V1: Not contract");
-        require(Address.isContract(_bnbNbuPair), "NimbusTikToken_V1: Not contract");
-        require(Address.isContract(_gnbuBnbPair), "NimbusTikToken_V1: Not contract");
-        require(Address.isContract(_lpStakingBnbNbu), "NimbusTikToken_V1: Not contract");
-        require(Address.isContract(_lpStakingBnbGnbu), "NimbusTikToken_V1: Not contract");
-        require(Address.isContract(_lendingContract), "NimbusTikToken_V1: Not contract");
-
-        _name = "TikToken";
-        _symbol = "TT";
+        require(Address.isContract(_swapRouter), "NimbusSmartLP_V1: Not contract");
+        require(Address.isContract(_wbnb), "NimbusSmartLP_V1: Not contract");
+        require(Address.isContract(_nbuToken), "NimbusSmartLP_V1: Not contract");
+        require(Address.isContract(_gnbuToken), "NimbusSmartLP_V1: Not contract");
+        require(Address.isContract(_bnbNbuPair), "NimbusSmartLP_V1: Not contract");
+        require(Address.isContract(_gnbuBnbPair), "NimbusSmartLP_V1: Not contract");
+        require(Address.isContract(_lpStakingBnbNbu), "NimbusSmartLP_V1: Not contract");
+        require(Address.isContract(_lpStakingBnbGnbu), "NimbusSmartLP_V1: Not contract");
+        require(Address.isContract(_lendingContract), "NimbusSmartLP_V1: Not contract");
+
+        _name = "Smart LP";
+        _symbol = "SL";
          
         swapRouter = IRouter(_swapRouter);
         WBNB = IWBNB(_wbnb);
@@ -462,7 +481,7 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
         lendingContract = ILending(_lendingContract);
 
         rewardDuration = ILpStaking(_lpStakingBnbNbu).rewardDuration();
-        minPurchaseAmount = 2.5 ether;
+        minPurchaseAmount = 1 ether;
 
         IBEP20(_nbuToken).approve(_swapRouter, type(uint256).max);
         IBEP20(_gnbuToken).approve(_swapRouter, type(uint256).max);
@@ -478,10 +497,10 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
     
 
 
-    // ========================== TikToken functions ==========================
+    // ========================== SmartLP functions ==========================
 
-    function buyTikToken() payable external {
-      require(msg.value >= minPurchaseAmount, 'TikToken: min purchase is too low');
+    function buySmartLP() payable external {
+      require(msg.value >= minPurchaseAmount, 'SmartLP: Token price is more than sent');
       uint amountBNB = msg.value;
       uint swapAmount = amountBNB/6;
       tokenCount = ++tokenCount;
@@ -517,6 +536,8 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
       UserSupply storage userSupply = tikSupplies[tokenCount];
       userSupply.ProvidedBnb = msg.value;
       userSupply.IsActive = true;
+      userSupply.PoolNbuAmount = amountsBnbNbuSwap[1];
+      userSupply.PoolGnbuAmount = amountsBnbGnbuSwap[1];
       userSupply.GnbuBnbLpAmount = liquidityBnbGnbu;
       userSupply.NbuBnbLpAmount = liquidityBnbNbu;
       userSupply.LendedITokenAmount = mintAmount;
@@ -530,21 +551,24 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
       _userTokens[msg.sender].push(tokenCount); 
       _mint(msg.sender, tokenCount);
       
-      emit BuyTikToken(msg.sender, tokenCount, msg.value, block.timestamp);
+      emit BuySmartLP(msg.sender, tokenCount, msg.value, block.timestamp);
     }
     
-    function withdrawUserRewards(uint tokenId) external {
-        require(_owners[tokenId] == msg.sender, "TikToken: Not token owner");
+    function withdrawUserRewards(uint tokenId) external nonReentrant {
+        require(_owners[tokenId] == msg.sender, "SmartLP: Not token owner");
         UserSupply memory userSupply = tikSupplies[tokenId];
-        require(userSupply.IsActive, "TikToken: Not active");
+        require(userSupply.IsActive, "SmartLP: Not active");
         (uint lpBnbNbuUserRewards, uint lpBnbGnbuUserRewards, ) = getTokenRewardsAmounts(tokenId);
         _withdrawUserRewards(tokenId, lpBnbNbuUserRewards, lpBnbGnbuUserRewards);
     }
     
-    function burnTikToken(uint tokenId) external {
-        require(_owners[tokenId] == msg.sender, "TikToken: Not token owner");
+    function burnSmartLP(uint tokenId) external nonReentrant {
+        require(_owners[tokenId] == msg.sender, "SmartLP: Not token owner");
         UserSupply storage userSupply = tikSupplies[tokenId];
-        require(userSupply.IsActive, "TikToken: Token not active");
+        require(userSupply.IsActive, "SmartLP: Token not active");
+        require(userSupply.LendedBNBAmount < ((userSupply.LendedITokenAmount *lendingContract.tokenPrice()) / 1e18),
+            "SmartLP: lending rewards are not available"
+        );
         (uint lpBnbNbuUserRewards, uint lpBnbGnbuUserRewards, ) = getTokenRewardsAmounts(tokenId);
         
         if(lpBnbNbuUserRewards + lpBnbGnbuUserRewards > 0) {
@@ -562,14 +586,14 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
         transferFrom(msg.sender, address(0x1), tokenId);
         userSupply.IsActive = false;
         
-        emit BurnTikToken(tokenId);      
+        emit BurnSmartLP(tokenId);      
     }
 
 
 
     function getTokenRewardsAmounts(uint tokenId) public view returns (uint lpBnbNbuUserRewards, uint lpBnbGnbuUserRewards, uint lendedUserRewards) {
         UserSupply memory userSupply = tikSupplies[tokenId];
-        require(userSupply.IsActive, "TikToken: Not active");
+        require(userSupply.IsActive, "SmartLP: Not active");
 
         lpBnbNbuUserRewards = (_balancesRewardEquivalentBnbNbu[tokenId] * ((block.timestamp - weightedStakeDate[tokenId]) * 100)) / (100 * rewardDuration);
         lpBnbGnbuUserRewards = (_balancesRewardEquivalentBnbGnbu[tokenId] * ((block.timestamp - weightedStakeDate[tokenId]) * 100)) / (100 * rewardDuration);
@@ -589,7 +613,7 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
 
     function _withdrawUserRewards(uint tokenId, uint lpBnbNbuUserRewards, uint lpBnbGnbuUserRewards) private {
         uint totalReward = lpBnbNbuUserRewards + lpBnbGnbuUserRewards;
-        require(totalReward > 0, "TikToken: Claim not enough");
+        require(totalReward > 0, "SmartLP: Claim not enough");
         if (nbuToken.balanceOf(address(this)) < totalReward) {
             lpStakingBnbNbu.getReward();
             if (nbuToken.balanceOf(address(this)) < totalReward) {
@@ -640,7 +664,7 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
     }
 
     function approve(address to, uint256 tokenId) public virtual override {
-        address owner = TikToken.ownerOf(tokenId);
+        address owner = SmartLP.ownerOf(tokenId);
         require(to != owner, "ERC721: approval to current owner");
 
         require(
@@ -696,7 +720,7 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
 
     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
         require(_exists(tokenId), "ERC721: operator query for nonexistent token");
-        address owner = TikToken.ownerOf(tokenId);
+        address owner = SmartLP.ownerOf(tokenId);
         return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
     }
 
@@ -723,7 +747,7 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
     }
 
     function _burn(uint256 tokenId) internal virtual {
-        address owner = TikToken.ownerOf(tokenId);
+        address owner = SmartLP.ownerOf(tokenId);
 
         // Clear approvals
         _approve(address(0), tokenId);
@@ -735,9 +759,17 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
     }
 
     function _transfer(address from, address to, uint256 tokenId) internal virtual {
-        require(TikToken.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
+        require(SmartLP.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
         require(to != address(0), "ERC721: transfer to the zero address");
 
+        _userTokens[msg.sender];
+
+        for (uint256 i; i < _userTokens[msg.sender].length; i++) {
+            if(_userTokens[msg.sender][i] == tokenId) {
+                _remove(i, msg.sender);
+                break;
+            }
+        }
         // Clear approvals from the previous owner
         _approve(address(0), tokenId);
 
@@ -748,9 +780,14 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
         emit Transfer(from, to, tokenId);
     }
 
+    function _remove(uint index, address tokenOwner) internal virtual {
+        _userTokens[tokenOwner][index] = _userTokens[tokenOwner][_userTokens[tokenOwner].length - 1];
+        _userTokens[tokenOwner].pop();
+    }
+
     function _approve(address to, uint256 tokenId) internal virtual {
         _tokenApprovals[tokenId] = to;
-        emit Approval(TikToken.ownerOf(tokenId), to, tokenId);
+        emit Approval(SmartLP.ownerOf(tokenId), to, tokenId);
     }
 
     function _setApprovalForAll( address owner, address operator, bool approved) internal virtual {
@@ -782,31 +819,31 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
     // ========================== Owner functions ==========================
 
     function updateSwapRouter(address newSwapRouter) external onlyOwner {
-        require(Address.isContract(newSwapRouter), "TikToken: Not a contract");
+        require(Address.isContract(newSwapRouter), "SmartLP: Not a contract");
         swapRouter = IRouter(newSwapRouter);
         emit UpdateSwapRouter(newSwapRouter);
     }
     
     function updateLpStakingBnbNbu(address newLpStaking) external onlyOwner {
-        require(Address.isContract(newLpStaking), "TikToken: Not a contract");
+        require(Address.isContract(newLpStaking), "SmartLP: Not a contract");
         lpStakingBnbNbu = ILpStaking(newLpStaking);
         emit UpdateLpStakingBnbNbu(newLpStaking);
     }
     
     function updateLpStakingBnbGnbu(address newLpStaking) external onlyOwner {
-        require(Address.isContract(newLpStaking), "TikToken: Not a contract");
+        require(Address.isContract(newLpStaking), "SmartLP: Not a contract");
         lpStakingBnbGnbu = ILpStaking(newLpStaking);
         emit UpdateLpStakingBnbGnbu(newLpStaking);
     }
     
     function updateLendingContract(address newLendingContract) external onlyOwner {
-        require(Address.isContract(newLendingContract), "TikToken: Not a contract");
+        require(Address.isContract(newLendingContract), "SmartLP: Not a contract");
         lendingContract = ILending(newLendingContract);
         emit UpdateLendingContract(newLendingContract);
     }
     
     function updateTokenAllowance(address token, address spender, int amount) external onlyOwner {
-        require(Address.isContract(token), "TikToken: Not a contract");
+        require(Address.isContract(token), "SmartLP: Not a contract");
         uint allowance;
         if (amount < 0) {
             allowance = type(uint256).max;
@@ -817,7 +854,7 @@ contract TikToken is TikTokenStorage, IBEP721, IBEP721Metadata {
     }
     
     function updateMinPurchaseAmount (uint newAmount) external onlyOwner {
-        require(newAmount > 0, "TikToken: Amount must be greater than zero");
+        require(newAmount > 0, "SmartLP: Amount must be greater than zero");
         minPurchaseAmount = newAmount;
         emit UpdateMinPurchaseAmount(newAmount);
     }