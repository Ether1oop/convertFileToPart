@@ -219,6 +219,8 @@ contract MasterChefV2 is BoringOwnable, BoringBatchable {
         // Interactions
         lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);
 
+        emit Deposit(msg.sender, pid, amount, to);
+
         address _rewarder = address(rewarder[pid]);
         if (_rewarder != address(0)) {
             // Note: Do it this way because we don't want to fail harvest if only the delegate call fails.
@@ -228,7 +230,6 @@ contract MasterChefV2 is BoringOwnable, BoringBatchable {
             _rewarder.call{ gas: gasleft() - 5000 }(abi.encodeWithSelector(SIG_ON_SUSHI_REWARD, pid, to, 0, user.amount));
         }
 
-        emit Deposit(msg.sender, pid, amount, to);
     }
 
     /// @notice Withdraw LP tokens from MCV2.
@@ -246,6 +247,8 @@ contract MasterChefV2 is BoringOwnable, BoringBatchable {
         // Interactions
         lpToken[pid].safeTransfer(to, amount);
 
+        emit Withdraw(msg.sender, pid, amount, to);
+
         address _rewarder = address(rewarder[pid]);
         if (_rewarder != address(0)) {
             // Note: Do it this way because we don't want to fail harvest if only the delegate call fails.
@@ -255,51 +258,54 @@ contract MasterChefV2 is BoringOwnable, BoringBatchable {
             _rewarder.call{ gas: gasleft() - 5000 }(abi.encodeWithSelector(SIG_ON_SUSHI_REWARD, pid, msg.sender, 0, user.amount));
         }
 
-        emit Withdraw(msg.sender, pid, amount, to);
     }
 
     /// @notice Harvest proceeds for transaction sender to `to`.
     /// @param pid The index of the pool. See `poolInfo`.
     /// @param to Receiver of SUSHI rewards.
-    /// @return success Returns bool indicating success of rewarder delegate call.
-    function harvest(uint256 pid, address to) public returns (bool success) {
+    function harvest(uint256 pid, address to) public {
         PoolInfo memory pool = updatePool(pid);
         UserInfo storage user = userInfo[pid][msg.sender];
         int256 accumulatedSushi = int256(user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION);
         uint256 _pendingSushi = accumulatedSushi.sub(user.rewardDebt).toUInt256();
-        if (_pendingSushi == 0) { success = false; }
 
         // Effects
         user.rewardDebt = accumulatedSushi;
 
         // Interactions
-        SUSHI.safeTransfer(to, _pendingSushi);
+        if (_pendingSushi == 0) {
+            SUSHI.safeTransfer(to, _pendingSushi);
+        }
+
+        emit Harvest(msg.sender, pid, _pendingSushi);
 
         address _rewarder = address(rewarder[pid]);
         if (_rewarder != address(0)) {
             // Note: Do it this way because we don't want to fail harvest if only the delegate call fails.
             // Additionally, forward less gas so that we have enough buffer to complete harvest if the call eats up too much gas.
             // Forwarding: (63/64 of gasleft by evm convention) minus 5000
             // solhint-disable-next-line
-            (success, ) = _rewarder.call{ gas: gasleft() - 5000 }(abi.encodeWithSelector(SIG_ON_SUSHI_REWARD, pid, to, _pendingSushi, user.amount));
+            _rewarder.call{ gas: gasleft() - 5000 }(abi.encodeWithSelector(SIG_ON_SUSHI_REWARD, pid, to, _pendingSushi, user.amount));
         }
 
-        emit Harvest(msg.sender, pid, _pendingSushi);
     }
 
     function withdrawAndHarvest(uint256 pid, uint256 amount, address to) public {
         PoolInfo memory pool = updatePool(pid);
         UserInfo storage user = userInfo[pid][msg.sender];
         int256 accumulatedSushi = int256(user.amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION);
         uint256 _pendingSushi = accumulatedSushi.sub(user.rewardDebt).toUInt256();
-        if (_pendingSushi == 0) { success = false; }
 
         // Effects
         user.rewardDebt = accumulatedSushi.sub(int256(amount.mul(pool.accSushiPerShare) / ACC_SUSHI_PRECISION));
         user.amount = user.amount.sub(amount);
         
         // Interactions
         SUSHI.safeTransfer(to, _pendingSushi);
+        lpToken[pid].safeTransfer(to, amount);
+
+        emit Withdraw(msg.sender, pid, amount, to);
+        emit Harvest(msg.sender, pid, _pendingSushi);
 
         address _rewarder = address(rewarder[pid]);
         if (_rewarder != address(0)) {
@@ -310,8 +316,6 @@ contract MasterChefV2 is BoringOwnable, BoringBatchable {
             _rewarder.call{ gas: gasleft() - 5000 }(abi.encodeWithSelector(SIG_ON_SUSHI_REWARD, pid, to, _pendingSushi, user.amount));
         }
 
-        emit Withdraw(msg.sender, pid, amount, to);
-        emit Harvest(msg.sender, pid, _pendingSushi);
     }
 
     /// @notice Harvests SUSHI from `MASTER_CHEF` MCV1 and pool `MASTER_PID` to this MCV2 contract.