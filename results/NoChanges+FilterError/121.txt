@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: UNLICENSED
-pragma solidity 0.7.0;
+pragma solidity 0.7.6;
 
 import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
 import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
@@ -29,15 +29,13 @@ contract CompoundYield is IYield, Initializable, OwnableUpgradeable, ReentrancyG
      */
     mapping(address => address) public override liquidityToken;
 
-
     /**
      * @notice emitted when all tokens are withdrawn, in case of emergencies
      * @param asset address of the token being withdrawn
      * @param withdrawTo address of the wallet to which tokens are withdrawn
      * @param tokensReceived amount of tokens received
      */
     event EmergencyWithdraw(address indexed asset, address indexed withdrawTo, uint256 tokensReceived);
-    
 
     /**
      * @notice emitted when liquidity token address of an asset is updated
@@ -113,7 +111,7 @@ contract CompoundYield is IYield, Initializable, OwnableUpgradeable, ReentrancyG
             received = _withdrawERC(_asset, investedTo, amount);
             IERC20(_asset).safeTransfer(_wallet, received);
         }
-        emit EmergencyWithdraw(_asset,_wallet,received);
+        emit EmergencyWithdraw(_asset, _wallet, received);
     }
 
     /**
@@ -218,6 +216,7 @@ contract CompoundYield is IYield, Initializable, OwnableUpgradeable, ReentrancyG
     ) internal returns (uint256 sharesReceived) {
         uint256 initialCTokenBalance = IERC20(cToken).balanceOf(address(this));
         //mint cToken
+        IERC20(asset).approve(cToken, 0);
         IERC20(asset).approve(cToken, amount);
         require(ICToken(cToken).mint(amount) == 0, 'Error in minting tokens');
         sharesReceived = IERC20(cToken).balanceOf(address(this)).sub(initialCTokenBalance);